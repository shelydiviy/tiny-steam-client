// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_clientserver_login.proto

#ifndef PROTOBUF_steammessages_5fclientserver_5flogin_2eproto__INCLUDED
#define PROTOBUF_steammessages_5fclientserver_5flogin_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "steammessages_base.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_steammessages_5fclientserver_5flogin_2eproto();
void protobuf_AssignDesc_steammessages_5fclientserver_5flogin_2eproto();
void protobuf_ShutdownFile_steammessages_5fclientserver_5flogin_2eproto();

class CMsgClientHeartBeat;
class CMsgClientServerTimestampRequest;
class CMsgClientServerTimestampResponse;
class CMsgClientSecret;
class CMsgClientHello;
class CMsgClientLogon;
class CMsgClientLogonResponse;
class CMsgClientRequestWebAPIAuthenticateUserNonce;
class CMsgClientRequestWebAPIAuthenticateUserNonceResponse;
class CMsgClientLogOff;
class CMsgClientLoggedOff;
class CMsgClientNewLoginKey;
class CMsgClientNewLoginKeyAccepted;
class CMsgClientAccountInfo;
class CMsgClientChallengeRequest;
class CMsgClientChallengeResponse;

// ===================================================================

class CMsgClientHeartBeat : public ::google::protobuf::Message {
 public:
  CMsgClientHeartBeat();
  virtual ~CMsgClientHeartBeat();

  CMsgClientHeartBeat(const CMsgClientHeartBeat& from);

  inline CMsgClientHeartBeat& operator=(const CMsgClientHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientHeartBeat& default_instance();

  void Swap(CMsgClientHeartBeat* other);

  // implements Message ----------------------------------------------

  CMsgClientHeartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientHeartBeat& from);
  void MergeFrom(const CMsgClientHeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool send_reply = 1;
  inline bool has_send_reply() const;
  inline void clear_send_reply();
  static const int kSendReplyFieldNumber = 1;
  inline bool send_reply() const;
  inline void set_send_reply(bool value);

  // @@protoc_insertion_point(class_scope:CMsgClientHeartBeat)
 private:
  inline void set_has_send_reply();
  inline void clear_has_send_reply();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool send_reply_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_AssignDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientHeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientServerTimestampRequest : public ::google::protobuf::Message {
 public:
  CMsgClientServerTimestampRequest();
  virtual ~CMsgClientServerTimestampRequest();

  CMsgClientServerTimestampRequest(const CMsgClientServerTimestampRequest& from);

  inline CMsgClientServerTimestampRequest& operator=(const CMsgClientServerTimestampRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientServerTimestampRequest& default_instance();

  void Swap(CMsgClientServerTimestampRequest* other);

  // implements Message ----------------------------------------------

  CMsgClientServerTimestampRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientServerTimestampRequest& from);
  void MergeFrom(const CMsgClientServerTimestampRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 client_request_timestamp = 1;
  inline bool has_client_request_timestamp() const;
  inline void clear_client_request_timestamp();
  static const int kClientRequestTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 client_request_timestamp() const;
  inline void set_client_request_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CMsgClientServerTimestampRequest)
 private:
  inline void set_has_client_request_timestamp();
  inline void clear_has_client_request_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 client_request_timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_AssignDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientServerTimestampRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientServerTimestampResponse : public ::google::protobuf::Message {
 public:
  CMsgClientServerTimestampResponse();
  virtual ~CMsgClientServerTimestampResponse();

  CMsgClientServerTimestampResponse(const CMsgClientServerTimestampResponse& from);

  inline CMsgClientServerTimestampResponse& operator=(const CMsgClientServerTimestampResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientServerTimestampResponse& default_instance();

  void Swap(CMsgClientServerTimestampResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientServerTimestampResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientServerTimestampResponse& from);
  void MergeFrom(const CMsgClientServerTimestampResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 client_request_timestamp = 1;
  inline bool has_client_request_timestamp() const;
  inline void clear_client_request_timestamp();
  static const int kClientRequestTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 client_request_timestamp() const;
  inline void set_client_request_timestamp(::google::protobuf::uint64 value);

  // optional uint64 server_timestamp_ms = 2;
  inline bool has_server_timestamp_ms() const;
  inline void clear_server_timestamp_ms();
  static const int kServerTimestampMsFieldNumber = 2;
  inline ::google::protobuf::uint64 server_timestamp_ms() const;
  inline void set_server_timestamp_ms(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CMsgClientServerTimestampResponse)
 private:
  inline void set_has_client_request_timestamp();
  inline void clear_has_client_request_timestamp();
  inline void set_has_server_timestamp_ms();
  inline void clear_has_server_timestamp_ms();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 client_request_timestamp_;
  ::google::protobuf::uint64 server_timestamp_ms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_AssignDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientServerTimestampResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientSecret : public ::google::protobuf::Message {
 public:
  CMsgClientSecret();
  virtual ~CMsgClientSecret();

  CMsgClientSecret(const CMsgClientSecret& from);

  inline CMsgClientSecret& operator=(const CMsgClientSecret& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientSecret& default_instance();

  void Swap(CMsgClientSecret* other);

  // implements Message ----------------------------------------------

  CMsgClientSecret* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientSecret& from);
  void MergeFrom(const CMsgClientSecret& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // optional uint32 appid = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 2;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // optional uint32 deviceid = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 3;
  inline ::google::protobuf::uint32 deviceid() const;
  inline void set_deviceid(::google::protobuf::uint32 value);

  // optional fixed64 nonce = 4;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 4;
  inline ::google::protobuf::uint64 nonce() const;
  inline void set_nonce(::google::protobuf::uint64 value);

  // optional bytes hmac = 5;
  inline bool has_hmac() const;
  inline void clear_hmac();
  static const int kHmacFieldNumber = 5;
  inline const ::std::string& hmac() const;
  inline void set_hmac(const ::std::string& value);
  inline void set_hmac(const char* value);
  inline void set_hmac(const void* value, size_t size);
  inline ::std::string* mutable_hmac();
  inline ::std::string* release_hmac();
  inline void set_allocated_hmac(::std::string* hmac);

  // @@protoc_insertion_point(class_scope:CMsgClientSecret)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_hmac();
  inline void clear_has_hmac();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 appid_;
  ::google::protobuf::uint64 nonce_;
  ::std::string* hmac_;
  ::google::protobuf::uint32 deviceid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_AssignDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientSecret* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientHello : public ::google::protobuf::Message {
 public:
  CMsgClientHello();
  virtual ~CMsgClientHello();

  CMsgClientHello(const CMsgClientHello& from);

  inline CMsgClientHello& operator=(const CMsgClientHello& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientHello& default_instance();

  void Swap(CMsgClientHello* other);

  // implements Message ----------------------------------------------

  CMsgClientHello* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientHello& from);
  void MergeFrom(const CMsgClientHello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 protocol_version = 1;
  inline bool has_protocol_version() const;
  inline void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 protocol_version() const;
  inline void set_protocol_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgClientHello)
 private:
  inline void set_has_protocol_version();
  inline void clear_has_protocol_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 protocol_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_AssignDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientHello* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLogon : public ::google::protobuf::Message {
 public:
  CMsgClientLogon();
  virtual ~CMsgClientLogon();

  CMsgClientLogon(const CMsgClientLogon& from);

  inline CMsgClientLogon& operator=(const CMsgClientLogon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientLogon& default_instance();

  void Swap(CMsgClientLogon* other);

  // implements Message ----------------------------------------------

  CMsgClientLogon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientLogon& from);
  void MergeFrom(const CMsgClientLogon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 protocol_version = 1;
  inline bool has_protocol_version() const;
  inline void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 protocol_version() const;
  inline void set_protocol_version(::google::protobuf::uint32 value);

  // optional uint32 deprecated_obfustucated_private_ip = 2;
  inline bool has_deprecated_obfustucated_private_ip() const;
  inline void clear_deprecated_obfustucated_private_ip();
  static const int kDeprecatedObfustucatedPrivateIpFieldNumber = 2;
  inline ::google::protobuf::uint32 deprecated_obfustucated_private_ip() const;
  inline void set_deprecated_obfustucated_private_ip(::google::protobuf::uint32 value);

  // optional uint32 cell_id = 3;
  inline bool has_cell_id() const;
  inline void clear_cell_id();
  static const int kCellIdFieldNumber = 3;
  inline ::google::protobuf::uint32 cell_id() const;
  inline void set_cell_id(::google::protobuf::uint32 value);

  // optional uint32 last_session_id = 4;
  inline bool has_last_session_id() const;
  inline void clear_last_session_id();
  static const int kLastSessionIdFieldNumber = 4;
  inline ::google::protobuf::uint32 last_session_id() const;
  inline void set_last_session_id(::google::protobuf::uint32 value);

  // optional uint32 client_package_version = 5;
  inline bool has_client_package_version() const;
  inline void clear_client_package_version();
  static const int kClientPackageVersionFieldNumber = 5;
  inline ::google::protobuf::uint32 client_package_version() const;
  inline void set_client_package_version(::google::protobuf::uint32 value);

  // optional string client_language = 6;
  inline bool has_client_language() const;
  inline void clear_client_language();
  static const int kClientLanguageFieldNumber = 6;
  inline const ::std::string& client_language() const;
  inline void set_client_language(const ::std::string& value);
  inline void set_client_language(const char* value);
  inline void set_client_language(const char* value, size_t size);
  inline ::std::string* mutable_client_language();
  inline ::std::string* release_client_language();
  inline void set_allocated_client_language(::std::string* client_language);

  // optional uint32 client_os_type = 7;
  inline bool has_client_os_type() const;
  inline void clear_client_os_type();
  static const int kClientOsTypeFieldNumber = 7;
  inline ::google::protobuf::uint32 client_os_type() const;
  inline void set_client_os_type(::google::protobuf::uint32 value);

  // optional bool should_remember_password = 8 [default = false];
  inline bool has_should_remember_password() const;
  inline void clear_should_remember_password();
  static const int kShouldRememberPasswordFieldNumber = 8;
  inline bool should_remember_password() const;
  inline void set_should_remember_password(bool value);

  // optional string wine_version = 9;
  inline bool has_wine_version() const;
  inline void clear_wine_version();
  static const int kWineVersionFieldNumber = 9;
  inline const ::std::string& wine_version() const;
  inline void set_wine_version(const ::std::string& value);
  inline void set_wine_version(const char* value);
  inline void set_wine_version(const char* value, size_t size);
  inline ::std::string* mutable_wine_version();
  inline ::std::string* release_wine_version();
  inline void set_allocated_wine_version(::std::string* wine_version);

  // optional uint32 deprecated_10 = 10;
  inline bool has_deprecated_10() const;
  inline void clear_deprecated_10();
  static const int kDeprecated10FieldNumber = 10;
  inline ::google::protobuf::uint32 deprecated_10() const;
  inline void set_deprecated_10(::google::protobuf::uint32 value);

  // optional .CMsgIPAddress obfuscated_private_ip = 11;
  inline bool has_obfuscated_private_ip() const;
  inline void clear_obfuscated_private_ip();
  static const int kObfuscatedPrivateIpFieldNumber = 11;
  inline const ::CMsgIPAddress& obfuscated_private_ip() const;
  inline ::CMsgIPAddress* mutable_obfuscated_private_ip();
  inline ::CMsgIPAddress* release_obfuscated_private_ip();
  inline void set_allocated_obfuscated_private_ip(::CMsgIPAddress* obfuscated_private_ip);

  // optional uint32 deprecated_public_ip = 20;
  inline bool has_deprecated_public_ip() const;
  inline void clear_deprecated_public_ip();
  static const int kDeprecatedPublicIpFieldNumber = 20;
  inline ::google::protobuf::uint32 deprecated_public_ip() const;
  inline void set_deprecated_public_ip(::google::protobuf::uint32 value);

  // optional uint32 qos_level = 21;
  inline bool has_qos_level() const;
  inline void clear_qos_level();
  static const int kQosLevelFieldNumber = 21;
  inline ::google::protobuf::uint32 qos_level() const;
  inline void set_qos_level(::google::protobuf::uint32 value);

  // optional fixed64 client_supplied_steam_id = 22;
  inline bool has_client_supplied_steam_id() const;
  inline void clear_client_supplied_steam_id();
  static const int kClientSuppliedSteamIdFieldNumber = 22;
  inline ::google::protobuf::uint64 client_supplied_steam_id() const;
  inline void set_client_supplied_steam_id(::google::protobuf::uint64 value);

  // optional .CMsgIPAddress public_ip = 23;
  inline bool has_public_ip() const;
  inline void clear_public_ip();
  static const int kPublicIpFieldNumber = 23;
  inline const ::CMsgIPAddress& public_ip() const;
  inline ::CMsgIPAddress* mutable_public_ip();
  inline ::CMsgIPAddress* release_public_ip();
  inline void set_allocated_public_ip(::CMsgIPAddress* public_ip);

  // optional bytes machine_id = 30;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 30;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const void* value, size_t size);
  inline ::std::string* mutable_machine_id();
  inline ::std::string* release_machine_id();
  inline void set_allocated_machine_id(::std::string* machine_id);

  // optional uint32 launcher_type = 31 [default = 0];
  inline bool has_launcher_type() const;
  inline void clear_launcher_type();
  static const int kLauncherTypeFieldNumber = 31;
  inline ::google::protobuf::uint32 launcher_type() const;
  inline void set_launcher_type(::google::protobuf::uint32 value);

  // optional uint32 ui_mode = 32 [default = 0];
  inline bool has_ui_mode() const;
  inline void clear_ui_mode();
  static const int kUiModeFieldNumber = 32;
  inline ::google::protobuf::uint32 ui_mode() const;
  inline void set_ui_mode(::google::protobuf::uint32 value);

  // optional uint32 chat_mode = 33 [default = 0];
  inline bool has_chat_mode() const;
  inline void clear_chat_mode();
  static const int kChatModeFieldNumber = 33;
  inline ::google::protobuf::uint32 chat_mode() const;
  inline void set_chat_mode(::google::protobuf::uint32 value);

  // optional bytes steam2_auth_ticket = 41;
  inline bool has_steam2_auth_ticket() const;
  inline void clear_steam2_auth_ticket();
  static const int kSteam2AuthTicketFieldNumber = 41;
  inline const ::std::string& steam2_auth_ticket() const;
  inline void set_steam2_auth_ticket(const ::std::string& value);
  inline void set_steam2_auth_ticket(const char* value);
  inline void set_steam2_auth_ticket(const void* value, size_t size);
  inline ::std::string* mutable_steam2_auth_ticket();
  inline ::std::string* release_steam2_auth_ticket();
  inline void set_allocated_steam2_auth_ticket(::std::string* steam2_auth_ticket);

  // optional string email_address = 42;
  inline bool has_email_address() const;
  inline void clear_email_address();
  static const int kEmailAddressFieldNumber = 42;
  inline const ::std::string& email_address() const;
  inline void set_email_address(const ::std::string& value);
  inline void set_email_address(const char* value);
  inline void set_email_address(const char* value, size_t size);
  inline ::std::string* mutable_email_address();
  inline ::std::string* release_email_address();
  inline void set_allocated_email_address(::std::string* email_address);

  // optional fixed32 rtime32_account_creation = 43;
  inline bool has_rtime32_account_creation() const;
  inline void clear_rtime32_account_creation();
  static const int kRtime32AccountCreationFieldNumber = 43;
  inline ::google::protobuf::uint32 rtime32_account_creation() const;
  inline void set_rtime32_account_creation(::google::protobuf::uint32 value);

  // optional string account_name = 50;
  inline bool has_account_name() const;
  inline void clear_account_name();
  static const int kAccountNameFieldNumber = 50;
  inline const ::std::string& account_name() const;
  inline void set_account_name(const ::std::string& value);
  inline void set_account_name(const char* value);
  inline void set_account_name(const char* value, size_t size);
  inline ::std::string* mutable_account_name();
  inline ::std::string* release_account_name();
  inline void set_allocated_account_name(::std::string* account_name);

  // optional string password = 51;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 51;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string game_server_token = 52;
  inline bool has_game_server_token() const;
  inline void clear_game_server_token();
  static const int kGameServerTokenFieldNumber = 52;
  inline const ::std::string& game_server_token() const;
  inline void set_game_server_token(const ::std::string& value);
  inline void set_game_server_token(const char* value);
  inline void set_game_server_token(const char* value, size_t size);
  inline ::std::string* mutable_game_server_token();
  inline ::std::string* release_game_server_token();
  inline void set_allocated_game_server_token(::std::string* game_server_token);

  // optional string login_key = 60;
  inline bool has_login_key() const;
  inline void clear_login_key();
  static const int kLoginKeyFieldNumber = 60;
  inline const ::std::string& login_key() const;
  inline void set_login_key(const ::std::string& value);
  inline void set_login_key(const char* value);
  inline void set_login_key(const char* value, size_t size);
  inline ::std::string* mutable_login_key();
  inline ::std::string* release_login_key();
  inline void set_allocated_login_key(::std::string* login_key);

  // optional bool was_converted_deprecated_msg = 70 [default = false];
  inline bool has_was_converted_deprecated_msg() const;
  inline void clear_was_converted_deprecated_msg();
  static const int kWasConvertedDeprecatedMsgFieldNumber = 70;
  inline bool was_converted_deprecated_msg() const;
  inline void set_was_converted_deprecated_msg(bool value);

  // optional string anon_user_target_account_name = 80;
  inline bool has_anon_user_target_account_name() const;
  inline void clear_anon_user_target_account_name();
  static const int kAnonUserTargetAccountNameFieldNumber = 80;
  inline const ::std::string& anon_user_target_account_name() const;
  inline void set_anon_user_target_account_name(const ::std::string& value);
  inline void set_anon_user_target_account_name(const char* value);
  inline void set_anon_user_target_account_name(const char* value, size_t size);
  inline ::std::string* mutable_anon_user_target_account_name();
  inline ::std::string* release_anon_user_target_account_name();
  inline void set_allocated_anon_user_target_account_name(::std::string* anon_user_target_account_name);

  // optional fixed64 resolved_user_steam_id = 81;
  inline bool has_resolved_user_steam_id() const;
  inline void clear_resolved_user_steam_id();
  static const int kResolvedUserSteamIdFieldNumber = 81;
  inline ::google::protobuf::uint64 resolved_user_steam_id() const;
  inline void set_resolved_user_steam_id(::google::protobuf::uint64 value);

  // optional int32 eresult_sentryfile = 82;
  inline bool has_eresult_sentryfile() const;
  inline void clear_eresult_sentryfile();
  static const int kEresultSentryfileFieldNumber = 82;
  inline ::google::protobuf::int32 eresult_sentryfile() const;
  inline void set_eresult_sentryfile(::google::protobuf::int32 value);

  // optional bytes sha_sentryfile = 83;
  inline bool has_sha_sentryfile() const;
  inline void clear_sha_sentryfile();
  static const int kShaSentryfileFieldNumber = 83;
  inline const ::std::string& sha_sentryfile() const;
  inline void set_sha_sentryfile(const ::std::string& value);
  inline void set_sha_sentryfile(const char* value);
  inline void set_sha_sentryfile(const void* value, size_t size);
  inline ::std::string* mutable_sha_sentryfile();
  inline ::std::string* release_sha_sentryfile();
  inline void set_allocated_sha_sentryfile(::std::string* sha_sentryfile);

  // optional string auth_code = 84;
  inline bool has_auth_code() const;
  inline void clear_auth_code();
  static const int kAuthCodeFieldNumber = 84;
  inline const ::std::string& auth_code() const;
  inline void set_auth_code(const ::std::string& value);
  inline void set_auth_code(const char* value);
  inline void set_auth_code(const char* value, size_t size);
  inline ::std::string* mutable_auth_code();
  inline ::std::string* release_auth_code();
  inline void set_allocated_auth_code(::std::string* auth_code);

  // optional int32 otp_type = 85;
  inline bool has_otp_type() const;
  inline void clear_otp_type();
  static const int kOtpTypeFieldNumber = 85;
  inline ::google::protobuf::int32 otp_type() const;
  inline void set_otp_type(::google::protobuf::int32 value);

  // optional uint32 otp_value = 86;
  inline bool has_otp_value() const;
  inline void clear_otp_value();
  static const int kOtpValueFieldNumber = 86;
  inline ::google::protobuf::uint32 otp_value() const;
  inline void set_otp_value(::google::protobuf::uint32 value);

  // optional string otp_identifier = 87;
  inline bool has_otp_identifier() const;
  inline void clear_otp_identifier();
  static const int kOtpIdentifierFieldNumber = 87;
  inline const ::std::string& otp_identifier() const;
  inline void set_otp_identifier(const ::std::string& value);
  inline void set_otp_identifier(const char* value);
  inline void set_otp_identifier(const char* value, size_t size);
  inline ::std::string* mutable_otp_identifier();
  inline ::std::string* release_otp_identifier();
  inline void set_allocated_otp_identifier(::std::string* otp_identifier);

  // optional bool steam2_ticket_request = 88;
  inline bool has_steam2_ticket_request() const;
  inline void clear_steam2_ticket_request();
  static const int kSteam2TicketRequestFieldNumber = 88;
  inline bool steam2_ticket_request() const;
  inline void set_steam2_ticket_request(bool value);

  // optional bytes sony_psn_ticket = 90;
  inline bool has_sony_psn_ticket() const;
  inline void clear_sony_psn_ticket();
  static const int kSonyPsnTicketFieldNumber = 90;
  inline const ::std::string& sony_psn_ticket() const;
  inline void set_sony_psn_ticket(const ::std::string& value);
  inline void set_sony_psn_ticket(const char* value);
  inline void set_sony_psn_ticket(const void* value, size_t size);
  inline ::std::string* mutable_sony_psn_ticket();
  inline ::std::string* release_sony_psn_ticket();
  inline void set_allocated_sony_psn_ticket(::std::string* sony_psn_ticket);

  // optional string sony_psn_service_id = 91;
  inline bool has_sony_psn_service_id() const;
  inline void clear_sony_psn_service_id();
  static const int kSonyPsnServiceIdFieldNumber = 91;
  inline const ::std::string& sony_psn_service_id() const;
  inline void set_sony_psn_service_id(const ::std::string& value);
  inline void set_sony_psn_service_id(const char* value);
  inline void set_sony_psn_service_id(const char* value, size_t size);
  inline ::std::string* mutable_sony_psn_service_id();
  inline ::std::string* release_sony_psn_service_id();
  inline void set_allocated_sony_psn_service_id(::std::string* sony_psn_service_id);

  // optional bool create_new_psn_linked_account_if_needed = 92 [default = false];
  inline bool has_create_new_psn_linked_account_if_needed() const;
  inline void clear_create_new_psn_linked_account_if_needed();
  static const int kCreateNewPsnLinkedAccountIfNeededFieldNumber = 92;
  inline bool create_new_psn_linked_account_if_needed() const;
  inline void set_create_new_psn_linked_account_if_needed(bool value);

  // optional string sony_psn_name = 93;
  inline bool has_sony_psn_name() const;
  inline void clear_sony_psn_name();
  static const int kSonyPsnNameFieldNumber = 93;
  inline const ::std::string& sony_psn_name() const;
  inline void set_sony_psn_name(const ::std::string& value);
  inline void set_sony_psn_name(const char* value);
  inline void set_sony_psn_name(const char* value, size_t size);
  inline ::std::string* mutable_sony_psn_name();
  inline ::std::string* release_sony_psn_name();
  inline void set_allocated_sony_psn_name(::std::string* sony_psn_name);

  // optional int32 game_server_app_id = 94;
  inline bool has_game_server_app_id() const;
  inline void clear_game_server_app_id();
  static const int kGameServerAppIdFieldNumber = 94;
  inline ::google::protobuf::int32 game_server_app_id() const;
  inline void set_game_server_app_id(::google::protobuf::int32 value);

  // optional bool steamguard_dont_remember_computer = 95;
  inline bool has_steamguard_dont_remember_computer() const;
  inline void clear_steamguard_dont_remember_computer();
  static const int kSteamguardDontRememberComputerFieldNumber = 95;
  inline bool steamguard_dont_remember_computer() const;
  inline void set_steamguard_dont_remember_computer(bool value);

  // optional string machine_name = 96;
  inline bool has_machine_name() const;
  inline void clear_machine_name();
  static const int kMachineNameFieldNumber = 96;
  inline const ::std::string& machine_name() const;
  inline void set_machine_name(const ::std::string& value);
  inline void set_machine_name(const char* value);
  inline void set_machine_name(const char* value, size_t size);
  inline ::std::string* mutable_machine_name();
  inline ::std::string* release_machine_name();
  inline void set_allocated_machine_name(::std::string* machine_name);

  // optional string machine_name_userchosen = 97;
  inline bool has_machine_name_userchosen() const;
  inline void clear_machine_name_userchosen();
  static const int kMachineNameUserchosenFieldNumber = 97;
  inline const ::std::string& machine_name_userchosen() const;
  inline void set_machine_name_userchosen(const ::std::string& value);
  inline void set_machine_name_userchosen(const char* value);
  inline void set_machine_name_userchosen(const char* value, size_t size);
  inline ::std::string* mutable_machine_name_userchosen();
  inline ::std::string* release_machine_name_userchosen();
  inline void set_allocated_machine_name_userchosen(::std::string* machine_name_userchosen);

  // optional string country_override = 98;
  inline bool has_country_override() const;
  inline void clear_country_override();
  static const int kCountryOverrideFieldNumber = 98;
  inline const ::std::string& country_override() const;
  inline void set_country_override(const ::std::string& value);
  inline void set_country_override(const char* value);
  inline void set_country_override(const char* value, size_t size);
  inline ::std::string* mutable_country_override();
  inline ::std::string* release_country_override();
  inline void set_allocated_country_override(::std::string* country_override);

  // optional bool is_steam_box = 99;
  inline bool has_is_steam_box() const;
  inline void clear_is_steam_box();
  static const int kIsSteamBoxFieldNumber = 99;
  inline bool is_steam_box() const;
  inline void set_is_steam_box(bool value);

  // optional uint64 client_instance_id = 100;
  inline bool has_client_instance_id() const;
  inline void clear_client_instance_id();
  static const int kClientInstanceIdFieldNumber = 100;
  inline ::google::protobuf::uint64 client_instance_id() const;
  inline void set_client_instance_id(::google::protobuf::uint64 value);

  // optional string two_factor_code = 101;
  inline bool has_two_factor_code() const;
  inline void clear_two_factor_code();
  static const int kTwoFactorCodeFieldNumber = 101;
  inline const ::std::string& two_factor_code() const;
  inline void set_two_factor_code(const ::std::string& value);
  inline void set_two_factor_code(const char* value);
  inline void set_two_factor_code(const char* value, size_t size);
  inline ::std::string* mutable_two_factor_code();
  inline ::std::string* release_two_factor_code();
  inline void set_allocated_two_factor_code(::std::string* two_factor_code);

  // optional bool supports_rate_limit_response = 102;
  inline bool has_supports_rate_limit_response() const;
  inline void clear_supports_rate_limit_response();
  static const int kSupportsRateLimitResponseFieldNumber = 102;
  inline bool supports_rate_limit_response() const;
  inline void set_supports_rate_limit_response(bool value);

  // optional string web_logon_nonce = 103;
  inline bool has_web_logon_nonce() const;
  inline void clear_web_logon_nonce();
  static const int kWebLogonNonceFieldNumber = 103;
  inline const ::std::string& web_logon_nonce() const;
  inline void set_web_logon_nonce(const ::std::string& value);
  inline void set_web_logon_nonce(const char* value);
  inline void set_web_logon_nonce(const char* value, size_t size);
  inline ::std::string* mutable_web_logon_nonce();
  inline ::std::string* release_web_logon_nonce();
  inline void set_allocated_web_logon_nonce(::std::string* web_logon_nonce);

  // optional int32 priority_reason = 104;
  inline bool has_priority_reason() const;
  inline void clear_priority_reason();
  static const int kPriorityReasonFieldNumber = 104;
  inline ::google::protobuf::int32 priority_reason() const;
  inline void set_priority_reason(::google::protobuf::int32 value);

  // optional .CMsgClientSecret embedded_client_secret = 105;
  inline bool has_embedded_client_secret() const;
  inline void clear_embedded_client_secret();
  static const int kEmbeddedClientSecretFieldNumber = 105;
  inline const ::CMsgClientSecret& embedded_client_secret() const;
  inline ::CMsgClientSecret* mutable_embedded_client_secret();
  inline ::CMsgClientSecret* release_embedded_client_secret();
  inline void set_allocated_embedded_client_secret(::CMsgClientSecret* embedded_client_secret);

  // optional bool disable_partner_autogrants = 106;
  inline bool has_disable_partner_autogrants() const;
  inline void clear_disable_partner_autogrants();
  static const int kDisablePartnerAutograntsFieldNumber = 106;
  inline bool disable_partner_autogrants() const;
  inline void set_disable_partner_autogrants(bool value);

  // optional bool is_steam_deck = 107;
  inline bool has_is_steam_deck() const;
  inline void clear_is_steam_deck();
  static const int kIsSteamDeckFieldNumber = 107;
  inline bool is_steam_deck() const;
  inline void set_is_steam_deck(bool value);

  // optional string access_token = 108;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 108;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // @@protoc_insertion_point(class_scope:CMsgClientLogon)
 private:
  inline void set_has_protocol_version();
  inline void clear_has_protocol_version();
  inline void set_has_deprecated_obfustucated_private_ip();
  inline void clear_has_deprecated_obfustucated_private_ip();
  inline void set_has_cell_id();
  inline void clear_has_cell_id();
  inline void set_has_last_session_id();
  inline void clear_has_last_session_id();
  inline void set_has_client_package_version();
  inline void clear_has_client_package_version();
  inline void set_has_client_language();
  inline void clear_has_client_language();
  inline void set_has_client_os_type();
  inline void clear_has_client_os_type();
  inline void set_has_should_remember_password();
  inline void clear_has_should_remember_password();
  inline void set_has_wine_version();
  inline void clear_has_wine_version();
  inline void set_has_deprecated_10();
  inline void clear_has_deprecated_10();
  inline void set_has_obfuscated_private_ip();
  inline void clear_has_obfuscated_private_ip();
  inline void set_has_deprecated_public_ip();
  inline void clear_has_deprecated_public_ip();
  inline void set_has_qos_level();
  inline void clear_has_qos_level();
  inline void set_has_client_supplied_steam_id();
  inline void clear_has_client_supplied_steam_id();
  inline void set_has_public_ip();
  inline void clear_has_public_ip();
  inline void set_has_machine_id();
  inline void clear_has_machine_id();
  inline void set_has_launcher_type();
  inline void clear_has_launcher_type();
  inline void set_has_ui_mode();
  inline void clear_has_ui_mode();
  inline void set_has_chat_mode();
  inline void clear_has_chat_mode();
  inline void set_has_steam2_auth_ticket();
  inline void clear_has_steam2_auth_ticket();
  inline void set_has_email_address();
  inline void clear_has_email_address();
  inline void set_has_rtime32_account_creation();
  inline void clear_has_rtime32_account_creation();
  inline void set_has_account_name();
  inline void clear_has_account_name();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_game_server_token();
  inline void clear_has_game_server_token();
  inline void set_has_login_key();
  inline void clear_has_login_key();
  inline void set_has_was_converted_deprecated_msg();
  inline void clear_has_was_converted_deprecated_msg();
  inline void set_has_anon_user_target_account_name();
  inline void clear_has_anon_user_target_account_name();
  inline void set_has_resolved_user_steam_id();
  inline void clear_has_resolved_user_steam_id();
  inline void set_has_eresult_sentryfile();
  inline void clear_has_eresult_sentryfile();
  inline void set_has_sha_sentryfile();
  inline void clear_has_sha_sentryfile();
  inline void set_has_auth_code();
  inline void clear_has_auth_code();
  inline void set_has_otp_type();
  inline void clear_has_otp_type();
  inline void set_has_otp_value();
  inline void clear_has_otp_value();
  inline void set_has_otp_identifier();
  inline void clear_has_otp_identifier();
  inline void set_has_steam2_ticket_request();
  inline void clear_has_steam2_ticket_request();
  inline void set_has_sony_psn_ticket();
  inline void clear_has_sony_psn_ticket();
  inline void set_has_sony_psn_service_id();
  inline void clear_has_sony_psn_service_id();
  inline void set_has_create_new_psn_linked_account_if_needed();
  inline void clear_has_create_new_psn_linked_account_if_needed();
  inline void set_has_sony_psn_name();
  inline void clear_has_sony_psn_name();
  inline void set_has_game_server_app_id();
  inline void clear_has_game_server_app_id();
  inline void set_has_steamguard_dont_remember_computer();
  inline void clear_has_steamguard_dont_remember_computer();
  inline void set_has_machine_name();
  inline void clear_has_machine_name();
  inline void set_has_machine_name_userchosen();
  inline void clear_has_machine_name_userchosen();
  inline void set_has_country_override();
  inline void clear_has_country_override();
  inline void set_has_is_steam_box();
  inline void clear_has_is_steam_box();
  inline void set_has_client_instance_id();
  inline void clear_has_client_instance_id();
  inline void set_has_two_factor_code();
  inline void clear_has_two_factor_code();
  inline void set_has_supports_rate_limit_response();
  inline void clear_has_supports_rate_limit_response();
  inline void set_has_web_logon_nonce();
  inline void clear_has_web_logon_nonce();
  inline void set_has_priority_reason();
  inline void clear_has_priority_reason();
  inline void set_has_embedded_client_secret();
  inline void clear_has_embedded_client_secret();
  inline void set_has_disable_partner_autogrants();
  inline void clear_has_disable_partner_autogrants();
  inline void set_has_is_steam_deck();
  inline void clear_has_is_steam_deck();
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 protocol_version_;
  ::google::protobuf::uint32 deprecated_obfustucated_private_ip_;
  ::google::protobuf::uint32 cell_id_;
  ::google::protobuf::uint32 last_session_id_;
  ::google::protobuf::uint32 client_package_version_;
  ::google::protobuf::uint32 client_os_type_;
  ::std::string* client_language_;
  ::std::string* wine_version_;
  ::CMsgIPAddress* obfuscated_private_ip_;
  ::google::protobuf::uint32 deprecated_10_;
  ::google::protobuf::uint32 deprecated_public_ip_;
  ::google::protobuf::uint64 client_supplied_steam_id_;
  ::CMsgIPAddress* public_ip_;
  ::google::protobuf::uint32 qos_level_;
  ::google::protobuf::uint32 launcher_type_;
  ::std::string* machine_id_;
  ::google::protobuf::uint32 ui_mode_;
  ::google::protobuf::uint32 chat_mode_;
  ::std::string* steam2_auth_ticket_;
  ::std::string* email_address_;
  ::std::string* account_name_;
  ::std::string* password_;
  ::std::string* game_server_token_;
  ::std::string* login_key_;
  ::google::protobuf::uint32 rtime32_account_creation_;
  bool should_remember_password_;
  bool was_converted_deprecated_msg_;
  bool steam2_ticket_request_;
  bool create_new_psn_linked_account_if_needed_;
  ::std::string* anon_user_target_account_name_;
  ::google::protobuf::uint64 resolved_user_steam_id_;
  ::std::string* sha_sentryfile_;
  ::google::protobuf::int32 eresult_sentryfile_;
  ::google::protobuf::int32 otp_type_;
  ::std::string* auth_code_;
  ::std::string* otp_identifier_;
  ::std::string* sony_psn_ticket_;
  ::google::protobuf::uint32 otp_value_;
  ::google::protobuf::int32 game_server_app_id_;
  ::std::string* sony_psn_service_id_;
  ::std::string* sony_psn_name_;
  ::std::string* machine_name_;
  ::std::string* machine_name_userchosen_;
  ::std::string* country_override_;
  ::google::protobuf::uint64 client_instance_id_;
  ::std::string* two_factor_code_;
  bool steamguard_dont_remember_computer_;
  bool is_steam_box_;
  bool supports_rate_limit_response_;
  bool disable_partner_autogrants_;
  ::google::protobuf::int32 priority_reason_;
  ::std::string* web_logon_nonce_;
  ::CMsgClientSecret* embedded_client_secret_;
  ::std::string* access_token_;
  bool is_steam_deck_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(55 + 31) / 32];

  friend void  protobuf_AddDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_AssignDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLogon* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLogonResponse : public ::google::protobuf::Message {
 public:
  CMsgClientLogonResponse();
  virtual ~CMsgClientLogonResponse();

  CMsgClientLogonResponse(const CMsgClientLogonResponse& from);

  inline CMsgClientLogonResponse& operator=(const CMsgClientLogonResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientLogonResponse& default_instance();

  void Swap(CMsgClientLogonResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientLogonResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientLogonResponse& from);
  void MergeFrom(const CMsgClientLogonResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional int32 legacy_out_of_game_heartbeat_seconds = 2;
  inline bool has_legacy_out_of_game_heartbeat_seconds() const;
  inline void clear_legacy_out_of_game_heartbeat_seconds();
  static const int kLegacyOutOfGameHeartbeatSecondsFieldNumber = 2;
  inline ::google::protobuf::int32 legacy_out_of_game_heartbeat_seconds() const;
  inline void set_legacy_out_of_game_heartbeat_seconds(::google::protobuf::int32 value);

  // optional int32 heartbeat_seconds = 3;
  inline bool has_heartbeat_seconds() const;
  inline void clear_heartbeat_seconds();
  static const int kHeartbeatSecondsFieldNumber = 3;
  inline ::google::protobuf::int32 heartbeat_seconds() const;
  inline void set_heartbeat_seconds(::google::protobuf::int32 value);

  // optional uint32 deprecated_public_ip = 4;
  inline bool has_deprecated_public_ip() const;
  inline void clear_deprecated_public_ip();
  static const int kDeprecatedPublicIpFieldNumber = 4;
  inline ::google::protobuf::uint32 deprecated_public_ip() const;
  inline void set_deprecated_public_ip(::google::protobuf::uint32 value);

  // optional fixed32 rtime32_server_time = 5;
  inline bool has_rtime32_server_time() const;
  inline void clear_rtime32_server_time();
  static const int kRtime32ServerTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 rtime32_server_time() const;
  inline void set_rtime32_server_time(::google::protobuf::uint32 value);

  // optional uint32 account_flags = 6;
  inline bool has_account_flags() const;
  inline void clear_account_flags();
  static const int kAccountFlagsFieldNumber = 6;
  inline ::google::protobuf::uint32 account_flags() const;
  inline void set_account_flags(::google::protobuf::uint32 value);

  // optional uint32 cell_id = 7;
  inline bool has_cell_id() const;
  inline void clear_cell_id();
  static const int kCellIdFieldNumber = 7;
  inline ::google::protobuf::uint32 cell_id() const;
  inline void set_cell_id(::google::protobuf::uint32 value);

  // optional string email_domain = 8;
  inline bool has_email_domain() const;
  inline void clear_email_domain();
  static const int kEmailDomainFieldNumber = 8;
  inline const ::std::string& email_domain() const;
  inline void set_email_domain(const ::std::string& value);
  inline void set_email_domain(const char* value);
  inline void set_email_domain(const char* value, size_t size);
  inline ::std::string* mutable_email_domain();
  inline ::std::string* release_email_domain();
  inline void set_allocated_email_domain(::std::string* email_domain);

  // optional bytes steam2_ticket = 9;
  inline bool has_steam2_ticket() const;
  inline void clear_steam2_ticket();
  static const int kSteam2TicketFieldNumber = 9;
  inline const ::std::string& steam2_ticket() const;
  inline void set_steam2_ticket(const ::std::string& value);
  inline void set_steam2_ticket(const char* value);
  inline void set_steam2_ticket(const void* value, size_t size);
  inline ::std::string* mutable_steam2_ticket();
  inline ::std::string* release_steam2_ticket();
  inline void set_allocated_steam2_ticket(::std::string* steam2_ticket);

  // optional int32 eresult_extended = 10;
  inline bool has_eresult_extended() const;
  inline void clear_eresult_extended();
  static const int kEresultExtendedFieldNumber = 10;
  inline ::google::protobuf::int32 eresult_extended() const;
  inline void set_eresult_extended(::google::protobuf::int32 value);

  // optional string webapi_authenticate_user_nonce = 11;
  inline bool has_webapi_authenticate_user_nonce() const;
  inline void clear_webapi_authenticate_user_nonce();
  static const int kWebapiAuthenticateUserNonceFieldNumber = 11;
  inline const ::std::string& webapi_authenticate_user_nonce() const;
  inline void set_webapi_authenticate_user_nonce(const ::std::string& value);
  inline void set_webapi_authenticate_user_nonce(const char* value);
  inline void set_webapi_authenticate_user_nonce(const char* value, size_t size);
  inline ::std::string* mutable_webapi_authenticate_user_nonce();
  inline ::std::string* release_webapi_authenticate_user_nonce();
  inline void set_allocated_webapi_authenticate_user_nonce(::std::string* webapi_authenticate_user_nonce);

  // optional uint32 cell_id_ping_threshold = 12;
  inline bool has_cell_id_ping_threshold() const;
  inline void clear_cell_id_ping_threshold();
  static const int kCellIdPingThresholdFieldNumber = 12;
  inline ::google::protobuf::uint32 cell_id_ping_threshold() const;
  inline void set_cell_id_ping_threshold(::google::protobuf::uint32 value);

  // optional bool deprecated_use_pics = 13;
  inline bool has_deprecated_use_pics() const;
  inline void clear_deprecated_use_pics();
  static const int kDeprecatedUsePicsFieldNumber = 13;
  inline bool deprecated_use_pics() const;
  inline void set_deprecated_use_pics(bool value);

  // optional string vanity_url = 14;
  inline bool has_vanity_url() const;
  inline void clear_vanity_url();
  static const int kVanityUrlFieldNumber = 14;
  inline const ::std::string& vanity_url() const;
  inline void set_vanity_url(const ::std::string& value);
  inline void set_vanity_url(const char* value);
  inline void set_vanity_url(const char* value, size_t size);
  inline ::std::string* mutable_vanity_url();
  inline ::std::string* release_vanity_url();
  inline void set_allocated_vanity_url(::std::string* vanity_url);

  // optional .CMsgIPAddress public_ip = 15;
  inline bool has_public_ip() const;
  inline void clear_public_ip();
  static const int kPublicIpFieldNumber = 15;
  inline const ::CMsgIPAddress& public_ip() const;
  inline ::CMsgIPAddress* mutable_public_ip();
  inline ::CMsgIPAddress* release_public_ip();
  inline void set_allocated_public_ip(::CMsgIPAddress* public_ip);

  // optional fixed64 client_supplied_steamid = 20;
  inline bool has_client_supplied_steamid() const;
  inline void clear_client_supplied_steamid();
  static const int kClientSuppliedSteamidFieldNumber = 20;
  inline ::google::protobuf::uint64 client_supplied_steamid() const;
  inline void set_client_supplied_steamid(::google::protobuf::uint64 value);

  // optional string ip_country_code = 21;
  inline bool has_ip_country_code() const;
  inline void clear_ip_country_code();
  static const int kIpCountryCodeFieldNumber = 21;
  inline const ::std::string& ip_country_code() const;
  inline void set_ip_country_code(const ::std::string& value);
  inline void set_ip_country_code(const char* value);
  inline void set_ip_country_code(const char* value, size_t size);
  inline ::std::string* mutable_ip_country_code();
  inline ::std::string* release_ip_country_code();
  inline void set_allocated_ip_country_code(::std::string* ip_country_code);

  // optional bytes parental_settings = 22;
  inline bool has_parental_settings() const;
  inline void clear_parental_settings();
  static const int kParentalSettingsFieldNumber = 22;
  inline const ::std::string& parental_settings() const;
  inline void set_parental_settings(const ::std::string& value);
  inline void set_parental_settings(const char* value);
  inline void set_parental_settings(const void* value, size_t size);
  inline ::std::string* mutable_parental_settings();
  inline ::std::string* release_parental_settings();
  inline void set_allocated_parental_settings(::std::string* parental_settings);

  // optional bytes parental_setting_signature = 23;
  inline bool has_parental_setting_signature() const;
  inline void clear_parental_setting_signature();
  static const int kParentalSettingSignatureFieldNumber = 23;
  inline const ::std::string& parental_setting_signature() const;
  inline void set_parental_setting_signature(const ::std::string& value);
  inline void set_parental_setting_signature(const char* value);
  inline void set_parental_setting_signature(const void* value, size_t size);
  inline ::std::string* mutable_parental_setting_signature();
  inline ::std::string* release_parental_setting_signature();
  inline void set_allocated_parental_setting_signature(::std::string* parental_setting_signature);

  // optional int32 count_loginfailures_to_migrate = 24;
  inline bool has_count_loginfailures_to_migrate() const;
  inline void clear_count_loginfailures_to_migrate();
  static const int kCountLoginfailuresToMigrateFieldNumber = 24;
  inline ::google::protobuf::int32 count_loginfailures_to_migrate() const;
  inline void set_count_loginfailures_to_migrate(::google::protobuf::int32 value);

  // optional int32 count_disconnects_to_migrate = 25;
  inline bool has_count_disconnects_to_migrate() const;
  inline void clear_count_disconnects_to_migrate();
  static const int kCountDisconnectsToMigrateFieldNumber = 25;
  inline ::google::protobuf::int32 count_disconnects_to_migrate() const;
  inline void set_count_disconnects_to_migrate(::google::protobuf::int32 value);

  // optional int32 ogs_data_report_time_window = 26;
  inline bool has_ogs_data_report_time_window() const;
  inline void clear_ogs_data_report_time_window();
  static const int kOgsDataReportTimeWindowFieldNumber = 26;
  inline ::google::protobuf::int32 ogs_data_report_time_window() const;
  inline void set_ogs_data_report_time_window(::google::protobuf::int32 value);

  // optional uint64 client_instance_id = 27;
  inline bool has_client_instance_id() const;
  inline void clear_client_instance_id();
  static const int kClientInstanceIdFieldNumber = 27;
  inline ::google::protobuf::uint64 client_instance_id() const;
  inline void set_client_instance_id(::google::protobuf::uint64 value);

  // optional bool force_client_update_check = 28;
  inline bool has_force_client_update_check() const;
  inline void clear_force_client_update_check();
  static const int kForceClientUpdateCheckFieldNumber = 28;
  inline bool force_client_update_check() const;
  inline void set_force_client_update_check(bool value);

  // optional string agreement_session_url = 29;
  inline bool has_agreement_session_url() const;
  inline void clear_agreement_session_url();
  static const int kAgreementSessionUrlFieldNumber = 29;
  inline const ::std::string& agreement_session_url() const;
  inline void set_agreement_session_url(const ::std::string& value);
  inline void set_agreement_session_url(const char* value);
  inline void set_agreement_session_url(const char* value, size_t size);
  inline ::std::string* mutable_agreement_session_url();
  inline ::std::string* release_agreement_session_url();
  inline void set_allocated_agreement_session_url(::std::string* agreement_session_url);

  // optional uint64 token_id = 30;
  inline bool has_token_id() const;
  inline void clear_token_id();
  static const int kTokenIdFieldNumber = 30;
  inline ::google::protobuf::uint64 token_id() const;
  inline void set_token_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CMsgClientLogonResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_legacy_out_of_game_heartbeat_seconds();
  inline void clear_has_legacy_out_of_game_heartbeat_seconds();
  inline void set_has_heartbeat_seconds();
  inline void clear_has_heartbeat_seconds();
  inline void set_has_deprecated_public_ip();
  inline void clear_has_deprecated_public_ip();
  inline void set_has_rtime32_server_time();
  inline void clear_has_rtime32_server_time();
  inline void set_has_account_flags();
  inline void clear_has_account_flags();
  inline void set_has_cell_id();
  inline void clear_has_cell_id();
  inline void set_has_email_domain();
  inline void clear_has_email_domain();
  inline void set_has_steam2_ticket();
  inline void clear_has_steam2_ticket();
  inline void set_has_eresult_extended();
  inline void clear_has_eresult_extended();
  inline void set_has_webapi_authenticate_user_nonce();
  inline void clear_has_webapi_authenticate_user_nonce();
  inline void set_has_cell_id_ping_threshold();
  inline void clear_has_cell_id_ping_threshold();
  inline void set_has_deprecated_use_pics();
  inline void clear_has_deprecated_use_pics();
  inline void set_has_vanity_url();
  inline void clear_has_vanity_url();
  inline void set_has_public_ip();
  inline void clear_has_public_ip();
  inline void set_has_client_supplied_steamid();
  inline void clear_has_client_supplied_steamid();
  inline void set_has_ip_country_code();
  inline void clear_has_ip_country_code();
  inline void set_has_parental_settings();
  inline void clear_has_parental_settings();
  inline void set_has_parental_setting_signature();
  inline void clear_has_parental_setting_signature();
  inline void set_has_count_loginfailures_to_migrate();
  inline void clear_has_count_loginfailures_to_migrate();
  inline void set_has_count_disconnects_to_migrate();
  inline void clear_has_count_disconnects_to_migrate();
  inline void set_has_ogs_data_report_time_window();
  inline void clear_has_ogs_data_report_time_window();
  inline void set_has_client_instance_id();
  inline void clear_has_client_instance_id();
  inline void set_has_force_client_update_check();
  inline void clear_has_force_client_update_check();
  inline void set_has_agreement_session_url();
  inline void clear_has_agreement_session_url();
  inline void set_has_token_id();
  inline void clear_has_token_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 eresult_;
  ::google::protobuf::int32 legacy_out_of_game_heartbeat_seconds_;
  ::google::protobuf::int32 heartbeat_seconds_;
  ::google::protobuf::uint32 deprecated_public_ip_;
  ::google::protobuf::uint32 rtime32_server_time_;
  ::google::protobuf::uint32 account_flags_;
  ::std::string* email_domain_;
  ::google::protobuf::uint32 cell_id_;
  ::google::protobuf::int32 eresult_extended_;
  ::std::string* steam2_ticket_;
  ::std::string* webapi_authenticate_user_nonce_;
  ::std::string* vanity_url_;
  ::CMsgIPAddress* public_ip_;
  ::google::protobuf::uint64 client_supplied_steamid_;
  ::google::protobuf::uint32 cell_id_ping_threshold_;
  bool deprecated_use_pics_;
  bool force_client_update_check_;
  ::std::string* ip_country_code_;
  ::std::string* parental_settings_;
  ::std::string* parental_setting_signature_;
  ::google::protobuf::int32 count_loginfailures_to_migrate_;
  ::google::protobuf::int32 count_disconnects_to_migrate_;
  ::google::protobuf::uint64 client_instance_id_;
  ::std::string* agreement_session_url_;
  ::google::protobuf::uint64 token_id_;
  ::google::protobuf::int32 ogs_data_report_time_window_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];

  friend void  protobuf_AddDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_AssignDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLogonResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestWebAPIAuthenticateUserNonce : public ::google::protobuf::Message {
 public:
  CMsgClientRequestWebAPIAuthenticateUserNonce();
  virtual ~CMsgClientRequestWebAPIAuthenticateUserNonce();

  CMsgClientRequestWebAPIAuthenticateUserNonce(const CMsgClientRequestWebAPIAuthenticateUserNonce& from);

  inline CMsgClientRequestWebAPIAuthenticateUserNonce& operator=(const CMsgClientRequestWebAPIAuthenticateUserNonce& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientRequestWebAPIAuthenticateUserNonce& default_instance();

  void Swap(CMsgClientRequestWebAPIAuthenticateUserNonce* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestWebAPIAuthenticateUserNonce* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientRequestWebAPIAuthenticateUserNonce& from);
  void MergeFrom(const CMsgClientRequestWebAPIAuthenticateUserNonce& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 token_type = 1 [default = -1];
  inline bool has_token_type() const;
  inline void clear_token_type();
  static const int kTokenTypeFieldNumber = 1;
  inline ::google::protobuf::int32 token_type() const;
  inline void set_token_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CMsgClientRequestWebAPIAuthenticateUserNonce)
 private:
  inline void set_has_token_type();
  inline void clear_has_token_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 token_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_AssignDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestWebAPIAuthenticateUserNonce* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientRequestWebAPIAuthenticateUserNonceResponse : public ::google::protobuf::Message {
 public:
  CMsgClientRequestWebAPIAuthenticateUserNonceResponse();
  virtual ~CMsgClientRequestWebAPIAuthenticateUserNonceResponse();

  CMsgClientRequestWebAPIAuthenticateUserNonceResponse(const CMsgClientRequestWebAPIAuthenticateUserNonceResponse& from);

  inline CMsgClientRequestWebAPIAuthenticateUserNonceResponse& operator=(const CMsgClientRequestWebAPIAuthenticateUserNonceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientRequestWebAPIAuthenticateUserNonceResponse& default_instance();

  void Swap(CMsgClientRequestWebAPIAuthenticateUserNonceResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientRequestWebAPIAuthenticateUserNonceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientRequestWebAPIAuthenticateUserNonceResponse& from);
  void MergeFrom(const CMsgClientRequestWebAPIAuthenticateUserNonceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // optional string webapi_authenticate_user_nonce = 11;
  inline bool has_webapi_authenticate_user_nonce() const;
  inline void clear_webapi_authenticate_user_nonce();
  static const int kWebapiAuthenticateUserNonceFieldNumber = 11;
  inline const ::std::string& webapi_authenticate_user_nonce() const;
  inline void set_webapi_authenticate_user_nonce(const ::std::string& value);
  inline void set_webapi_authenticate_user_nonce(const char* value);
  inline void set_webapi_authenticate_user_nonce(const char* value, size_t size);
  inline ::std::string* mutable_webapi_authenticate_user_nonce();
  inline ::std::string* release_webapi_authenticate_user_nonce();
  inline void set_allocated_webapi_authenticate_user_nonce(::std::string* webapi_authenticate_user_nonce);

  // optional int32 token_type = 3 [default = -1];
  inline bool has_token_type() const;
  inline void clear_token_type();
  static const int kTokenTypeFieldNumber = 3;
  inline ::google::protobuf::int32 token_type() const;
  inline void set_token_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CMsgClientRequestWebAPIAuthenticateUserNonceResponse)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();
  inline void set_has_webapi_authenticate_user_nonce();
  inline void clear_has_webapi_authenticate_user_nonce();
  inline void set_has_token_type();
  inline void clear_has_token_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* webapi_authenticate_user_nonce_;
  ::google::protobuf::int32 eresult_;
  ::google::protobuf::int32 token_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_AssignDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientRequestWebAPIAuthenticateUserNonceResponse* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLogOff : public ::google::protobuf::Message {
 public:
  CMsgClientLogOff();
  virtual ~CMsgClientLogOff();

  CMsgClientLogOff(const CMsgClientLogOff& from);

  inline CMsgClientLogOff& operator=(const CMsgClientLogOff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientLogOff& default_instance();

  void Swap(CMsgClientLogOff* other);

  // implements Message ----------------------------------------------

  CMsgClientLogOff* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientLogOff& from);
  void MergeFrom(const CMsgClientLogOff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CMsgClientLogOff)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_AssignDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLogOff* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientLoggedOff : public ::google::protobuf::Message {
 public:
  CMsgClientLoggedOff();
  virtual ~CMsgClientLoggedOff();

  CMsgClientLoggedOff(const CMsgClientLoggedOff& from);

  inline CMsgClientLoggedOff& operator=(const CMsgClientLoggedOff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientLoggedOff& default_instance();

  void Swap(CMsgClientLoggedOff* other);

  // implements Message ----------------------------------------------

  CMsgClientLoggedOff* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientLoggedOff& from);
  void MergeFrom(const CMsgClientLoggedOff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 eresult = 1 [default = 2];
  inline bool has_eresult() const;
  inline void clear_eresult();
  static const int kEresultFieldNumber = 1;
  inline ::google::protobuf::int32 eresult() const;
  inline void set_eresult(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CMsgClientLoggedOff)
 private:
  inline void set_has_eresult();
  inline void clear_has_eresult();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 eresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_AssignDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientLoggedOff* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientNewLoginKey : public ::google::protobuf::Message {
 public:
  CMsgClientNewLoginKey();
  virtual ~CMsgClientNewLoginKey();

  CMsgClientNewLoginKey(const CMsgClientNewLoginKey& from);

  inline CMsgClientNewLoginKey& operator=(const CMsgClientNewLoginKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientNewLoginKey& default_instance();

  void Swap(CMsgClientNewLoginKey* other);

  // implements Message ----------------------------------------------

  CMsgClientNewLoginKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientNewLoginKey& from);
  void MergeFrom(const CMsgClientNewLoginKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 unique_id = 1;
  inline bool has_unique_id() const;
  inline void clear_unique_id();
  static const int kUniqueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 unique_id() const;
  inline void set_unique_id(::google::protobuf::uint32 value);

  // optional string login_key = 2;
  inline bool has_login_key() const;
  inline void clear_login_key();
  static const int kLoginKeyFieldNumber = 2;
  inline const ::std::string& login_key() const;
  inline void set_login_key(const ::std::string& value);
  inline void set_login_key(const char* value);
  inline void set_login_key(const char* value, size_t size);
  inline ::std::string* mutable_login_key();
  inline ::std::string* release_login_key();
  inline void set_allocated_login_key(::std::string* login_key);

  // @@protoc_insertion_point(class_scope:CMsgClientNewLoginKey)
 private:
  inline void set_has_unique_id();
  inline void clear_has_unique_id();
  inline void set_has_login_key();
  inline void clear_has_login_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* login_key_;
  ::google::protobuf::uint32 unique_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_AssignDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientNewLoginKey* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientNewLoginKeyAccepted : public ::google::protobuf::Message {
 public:
  CMsgClientNewLoginKeyAccepted();
  virtual ~CMsgClientNewLoginKeyAccepted();

  CMsgClientNewLoginKeyAccepted(const CMsgClientNewLoginKeyAccepted& from);

  inline CMsgClientNewLoginKeyAccepted& operator=(const CMsgClientNewLoginKeyAccepted& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientNewLoginKeyAccepted& default_instance();

  void Swap(CMsgClientNewLoginKeyAccepted* other);

  // implements Message ----------------------------------------------

  CMsgClientNewLoginKeyAccepted* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientNewLoginKeyAccepted& from);
  void MergeFrom(const CMsgClientNewLoginKeyAccepted& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 unique_id = 1;
  inline bool has_unique_id() const;
  inline void clear_unique_id();
  static const int kUniqueIdFieldNumber = 1;
  inline ::google::protobuf::uint32 unique_id() const;
  inline void set_unique_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CMsgClientNewLoginKeyAccepted)
 private:
  inline void set_has_unique_id();
  inline void clear_has_unique_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 unique_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_AssignDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientNewLoginKeyAccepted* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientAccountInfo : public ::google::protobuf::Message {
 public:
  CMsgClientAccountInfo();
  virtual ~CMsgClientAccountInfo();

  CMsgClientAccountInfo(const CMsgClientAccountInfo& from);

  inline CMsgClientAccountInfo& operator=(const CMsgClientAccountInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientAccountInfo& default_instance();

  void Swap(CMsgClientAccountInfo* other);

  // implements Message ----------------------------------------------

  CMsgClientAccountInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientAccountInfo& from);
  void MergeFrom(const CMsgClientAccountInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string persona_name = 1;
  inline bool has_persona_name() const;
  inline void clear_persona_name();
  static const int kPersonaNameFieldNumber = 1;
  inline const ::std::string& persona_name() const;
  inline void set_persona_name(const ::std::string& value);
  inline void set_persona_name(const char* value);
  inline void set_persona_name(const char* value, size_t size);
  inline ::std::string* mutable_persona_name();
  inline ::std::string* release_persona_name();
  inline void set_allocated_persona_name(::std::string* persona_name);

  // optional string ip_country = 2;
  inline bool has_ip_country() const;
  inline void clear_ip_country();
  static const int kIpCountryFieldNumber = 2;
  inline const ::std::string& ip_country() const;
  inline void set_ip_country(const ::std::string& value);
  inline void set_ip_country(const char* value);
  inline void set_ip_country(const char* value, size_t size);
  inline ::std::string* mutable_ip_country();
  inline ::std::string* release_ip_country();
  inline void set_allocated_ip_country(::std::string* ip_country);

  // optional int32 count_authed_computers = 5;
  inline bool has_count_authed_computers() const;
  inline void clear_count_authed_computers();
  static const int kCountAuthedComputersFieldNumber = 5;
  inline ::google::protobuf::int32 count_authed_computers() const;
  inline void set_count_authed_computers(::google::protobuf::int32 value);

  // optional uint32 account_flags = 7;
  inline bool has_account_flags() const;
  inline void clear_account_flags();
  static const int kAccountFlagsFieldNumber = 7;
  inline ::google::protobuf::uint32 account_flags() const;
  inline void set_account_flags(::google::protobuf::uint32 value);

  // optional uint64 facebook_id = 8;
  inline bool has_facebook_id() const;
  inline void clear_facebook_id();
  static const int kFacebookIdFieldNumber = 8;
  inline ::google::protobuf::uint64 facebook_id() const;
  inline void set_facebook_id(::google::protobuf::uint64 value);

  // optional string facebook_name = 9;
  inline bool has_facebook_name() const;
  inline void clear_facebook_name();
  static const int kFacebookNameFieldNumber = 9;
  inline const ::std::string& facebook_name() const;
  inline void set_facebook_name(const ::std::string& value);
  inline void set_facebook_name(const char* value);
  inline void set_facebook_name(const char* value, size_t size);
  inline ::std::string* mutable_facebook_name();
  inline ::std::string* release_facebook_name();
  inline void set_allocated_facebook_name(::std::string* facebook_name);

  // optional bool steamguard_notify_newmachines = 14;
  inline bool has_steamguard_notify_newmachines() const;
  inline void clear_steamguard_notify_newmachines();
  static const int kSteamguardNotifyNewmachinesFieldNumber = 14;
  inline bool steamguard_notify_newmachines() const;
  inline void set_steamguard_notify_newmachines(bool value);

  // optional string steamguard_machine_name_user_chosen = 15;
  inline bool has_steamguard_machine_name_user_chosen() const;
  inline void clear_steamguard_machine_name_user_chosen();
  static const int kSteamguardMachineNameUserChosenFieldNumber = 15;
  inline const ::std::string& steamguard_machine_name_user_chosen() const;
  inline void set_steamguard_machine_name_user_chosen(const ::std::string& value);
  inline void set_steamguard_machine_name_user_chosen(const char* value);
  inline void set_steamguard_machine_name_user_chosen(const char* value, size_t size);
  inline ::std::string* mutable_steamguard_machine_name_user_chosen();
  inline ::std::string* release_steamguard_machine_name_user_chosen();
  inline void set_allocated_steamguard_machine_name_user_chosen(::std::string* steamguard_machine_name_user_chosen);

  // optional bool is_phone_verified = 16;
  inline bool has_is_phone_verified() const;
  inline void clear_is_phone_verified();
  static const int kIsPhoneVerifiedFieldNumber = 16;
  inline bool is_phone_verified() const;
  inline void set_is_phone_verified(bool value);

  // optional uint32 two_factor_state = 17;
  inline bool has_two_factor_state() const;
  inline void clear_two_factor_state();
  static const int kTwoFactorStateFieldNumber = 17;
  inline ::google::protobuf::uint32 two_factor_state() const;
  inline void set_two_factor_state(::google::protobuf::uint32 value);

  // optional bool is_phone_identifying = 18;
  inline bool has_is_phone_identifying() const;
  inline void clear_is_phone_identifying();
  static const int kIsPhoneIdentifyingFieldNumber = 18;
  inline bool is_phone_identifying() const;
  inline void set_is_phone_identifying(bool value);

  // optional bool is_phone_needing_reverify = 19;
  inline bool has_is_phone_needing_reverify() const;
  inline void clear_is_phone_needing_reverify();
  static const int kIsPhoneNeedingReverifyFieldNumber = 19;
  inline bool is_phone_needing_reverify() const;
  inline void set_is_phone_needing_reverify(bool value);

  // @@protoc_insertion_point(class_scope:CMsgClientAccountInfo)
 private:
  inline void set_has_persona_name();
  inline void clear_has_persona_name();
  inline void set_has_ip_country();
  inline void clear_has_ip_country();
  inline void set_has_count_authed_computers();
  inline void clear_has_count_authed_computers();
  inline void set_has_account_flags();
  inline void clear_has_account_flags();
  inline void set_has_facebook_id();
  inline void clear_has_facebook_id();
  inline void set_has_facebook_name();
  inline void clear_has_facebook_name();
  inline void set_has_steamguard_notify_newmachines();
  inline void clear_has_steamguard_notify_newmachines();
  inline void set_has_steamguard_machine_name_user_chosen();
  inline void clear_has_steamguard_machine_name_user_chosen();
  inline void set_has_is_phone_verified();
  inline void clear_has_is_phone_verified();
  inline void set_has_two_factor_state();
  inline void clear_has_two_factor_state();
  inline void set_has_is_phone_identifying();
  inline void clear_has_is_phone_identifying();
  inline void set_has_is_phone_needing_reverify();
  inline void clear_has_is_phone_needing_reverify();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* persona_name_;
  ::std::string* ip_country_;
  ::google::protobuf::int32 count_authed_computers_;
  ::google::protobuf::uint32 account_flags_;
  ::google::protobuf::uint64 facebook_id_;
  ::std::string* facebook_name_;
  ::std::string* steamguard_machine_name_user_chosen_;
  bool steamguard_notify_newmachines_;
  bool is_phone_verified_;
  bool is_phone_identifying_;
  bool is_phone_needing_reverify_;
  ::google::protobuf::uint32 two_factor_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_AssignDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientAccountInfo* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientChallengeRequest : public ::google::protobuf::Message {
 public:
  CMsgClientChallengeRequest();
  virtual ~CMsgClientChallengeRequest();

  CMsgClientChallengeRequest(const CMsgClientChallengeRequest& from);

  inline CMsgClientChallengeRequest& operator=(const CMsgClientChallengeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientChallengeRequest& default_instance();

  void Swap(CMsgClientChallengeRequest* other);

  // implements Message ----------------------------------------------

  CMsgClientChallengeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientChallengeRequest& from);
  void MergeFrom(const CMsgClientChallengeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 steamid = 1;
  inline bool has_steamid() const;
  inline void clear_steamid();
  static const int kSteamidFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid() const;
  inline void set_steamid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CMsgClientChallengeRequest)
 private:
  inline void set_has_steamid();
  inline void clear_has_steamid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 steamid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_AssignDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientChallengeRequest* default_instance_;
};
// -------------------------------------------------------------------

class CMsgClientChallengeResponse : public ::google::protobuf::Message {
 public:
  CMsgClientChallengeResponse();
  virtual ~CMsgClientChallengeResponse();

  CMsgClientChallengeResponse(const CMsgClientChallengeResponse& from);

  inline CMsgClientChallengeResponse& operator=(const CMsgClientChallengeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMsgClientChallengeResponse& default_instance();

  void Swap(CMsgClientChallengeResponse* other);

  // implements Message ----------------------------------------------

  CMsgClientChallengeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMsgClientChallengeResponse& from);
  void MergeFrom(const CMsgClientChallengeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 challenge = 1;
  inline bool has_challenge() const;
  inline void clear_challenge();
  static const int kChallengeFieldNumber = 1;
  inline ::google::protobuf::uint64 challenge() const;
  inline void set_challenge(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CMsgClientChallengeResponse)
 private:
  inline void set_has_challenge();
  inline void clear_has_challenge();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 challenge_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_AssignDesc_steammessages_5fclientserver_5flogin_2eproto();
  friend void protobuf_ShutdownFile_steammessages_5fclientserver_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CMsgClientChallengeResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// CMsgClientHeartBeat

// optional bool send_reply = 1;
inline bool CMsgClientHeartBeat::has_send_reply() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientHeartBeat::set_has_send_reply() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientHeartBeat::clear_has_send_reply() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientHeartBeat::clear_send_reply() {
  send_reply_ = false;
  clear_has_send_reply();
}
inline bool CMsgClientHeartBeat::send_reply() const {
  return send_reply_;
}
inline void CMsgClientHeartBeat::set_send_reply(bool value) {
  set_has_send_reply();
  send_reply_ = value;
}

// -------------------------------------------------------------------

// CMsgClientServerTimestampRequest

// optional uint64 client_request_timestamp = 1;
inline bool CMsgClientServerTimestampRequest::has_client_request_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientServerTimestampRequest::set_has_client_request_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientServerTimestampRequest::clear_has_client_request_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientServerTimestampRequest::clear_client_request_timestamp() {
  client_request_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_client_request_timestamp();
}
inline ::google::protobuf::uint64 CMsgClientServerTimestampRequest::client_request_timestamp() const {
  return client_request_timestamp_;
}
inline void CMsgClientServerTimestampRequest::set_client_request_timestamp(::google::protobuf::uint64 value) {
  set_has_client_request_timestamp();
  client_request_timestamp_ = value;
}

// -------------------------------------------------------------------

// CMsgClientServerTimestampResponse

// optional uint64 client_request_timestamp = 1;
inline bool CMsgClientServerTimestampResponse::has_client_request_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientServerTimestampResponse::set_has_client_request_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientServerTimestampResponse::clear_has_client_request_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientServerTimestampResponse::clear_client_request_timestamp() {
  client_request_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_client_request_timestamp();
}
inline ::google::protobuf::uint64 CMsgClientServerTimestampResponse::client_request_timestamp() const {
  return client_request_timestamp_;
}
inline void CMsgClientServerTimestampResponse::set_client_request_timestamp(::google::protobuf::uint64 value) {
  set_has_client_request_timestamp();
  client_request_timestamp_ = value;
}

// optional uint64 server_timestamp_ms = 2;
inline bool CMsgClientServerTimestampResponse::has_server_timestamp_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientServerTimestampResponse::set_has_server_timestamp_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientServerTimestampResponse::clear_has_server_timestamp_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientServerTimestampResponse::clear_server_timestamp_ms() {
  server_timestamp_ms_ = GOOGLE_ULONGLONG(0);
  clear_has_server_timestamp_ms();
}
inline ::google::protobuf::uint64 CMsgClientServerTimestampResponse::server_timestamp_ms() const {
  return server_timestamp_ms_;
}
inline void CMsgClientServerTimestampResponse::set_server_timestamp_ms(::google::protobuf::uint64 value) {
  set_has_server_timestamp_ms();
  server_timestamp_ms_ = value;
}

// -------------------------------------------------------------------

// CMsgClientSecret

// optional uint32 version = 1;
inline bool CMsgClientSecret::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientSecret::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientSecret::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientSecret::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 CMsgClientSecret::version() const {
  return version_;
}
inline void CMsgClientSecret::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// optional uint32 appid = 2;
inline bool CMsgClientSecret::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientSecret::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientSecret::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientSecret::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CMsgClientSecret::appid() const {
  return appid_;
}
inline void CMsgClientSecret::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
}

// optional uint32 deviceid = 3;
inline bool CMsgClientSecret::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientSecret::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientSecret::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientSecret::clear_deviceid() {
  deviceid_ = 0u;
  clear_has_deviceid();
}
inline ::google::protobuf::uint32 CMsgClientSecret::deviceid() const {
  return deviceid_;
}
inline void CMsgClientSecret::set_deviceid(::google::protobuf::uint32 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// optional fixed64 nonce = 4;
inline bool CMsgClientSecret::has_nonce() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientSecret::set_has_nonce() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientSecret::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientSecret::clear_nonce() {
  nonce_ = GOOGLE_ULONGLONG(0);
  clear_has_nonce();
}
inline ::google::protobuf::uint64 CMsgClientSecret::nonce() const {
  return nonce_;
}
inline void CMsgClientSecret::set_nonce(::google::protobuf::uint64 value) {
  set_has_nonce();
  nonce_ = value;
}

// optional bytes hmac = 5;
inline bool CMsgClientSecret::has_hmac() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientSecret::set_has_hmac() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientSecret::clear_has_hmac() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientSecret::clear_hmac() {
  if (hmac_ != &::google::protobuf::internal::kEmptyString) {
    hmac_->clear();
  }
  clear_has_hmac();
}
inline const ::std::string& CMsgClientSecret::hmac() const {
  return *hmac_;
}
inline void CMsgClientSecret::set_hmac(const ::std::string& value) {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    hmac_ = new ::std::string;
  }
  hmac_->assign(value);
}
inline void CMsgClientSecret::set_hmac(const char* value) {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    hmac_ = new ::std::string;
  }
  hmac_->assign(value);
}
inline void CMsgClientSecret::set_hmac(const void* value, size_t size) {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    hmac_ = new ::std::string;
  }
  hmac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientSecret::mutable_hmac() {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    hmac_ = new ::std::string;
  }
  return hmac_;
}
inline ::std::string* CMsgClientSecret::release_hmac() {
  clear_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hmac_;
    hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientSecret::set_allocated_hmac(::std::string* hmac) {
  if (hmac_ != &::google::protobuf::internal::kEmptyString) {
    delete hmac_;
  }
  if (hmac) {
    set_has_hmac();
    hmac_ = hmac;
  } else {
    clear_has_hmac();
    hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientHello

// optional uint32 protocol_version = 1;
inline bool CMsgClientHello::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientHello::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientHello::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientHello::clear_protocol_version() {
  protocol_version_ = 0u;
  clear_has_protocol_version();
}
inline ::google::protobuf::uint32 CMsgClientHello::protocol_version() const {
  return protocol_version_;
}
inline void CMsgClientHello::set_protocol_version(::google::protobuf::uint32 value) {
  set_has_protocol_version();
  protocol_version_ = value;
}

// -------------------------------------------------------------------

// CMsgClientLogon

// optional uint32 protocol_version = 1;
inline bool CMsgClientLogon::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientLogon::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientLogon::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientLogon::clear_protocol_version() {
  protocol_version_ = 0u;
  clear_has_protocol_version();
}
inline ::google::protobuf::uint32 CMsgClientLogon::protocol_version() const {
  return protocol_version_;
}
inline void CMsgClientLogon::set_protocol_version(::google::protobuf::uint32 value) {
  set_has_protocol_version();
  protocol_version_ = value;
}

// optional uint32 deprecated_obfustucated_private_ip = 2;
inline bool CMsgClientLogon::has_deprecated_obfustucated_private_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientLogon::set_has_deprecated_obfustucated_private_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientLogon::clear_has_deprecated_obfustucated_private_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientLogon::clear_deprecated_obfustucated_private_ip() {
  deprecated_obfustucated_private_ip_ = 0u;
  clear_has_deprecated_obfustucated_private_ip();
}
inline ::google::protobuf::uint32 CMsgClientLogon::deprecated_obfustucated_private_ip() const {
  return deprecated_obfustucated_private_ip_;
}
inline void CMsgClientLogon::set_deprecated_obfustucated_private_ip(::google::protobuf::uint32 value) {
  set_has_deprecated_obfustucated_private_ip();
  deprecated_obfustucated_private_ip_ = value;
}

// optional uint32 cell_id = 3;
inline bool CMsgClientLogon::has_cell_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientLogon::set_has_cell_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientLogon::clear_has_cell_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientLogon::clear_cell_id() {
  cell_id_ = 0u;
  clear_has_cell_id();
}
inline ::google::protobuf::uint32 CMsgClientLogon::cell_id() const {
  return cell_id_;
}
inline void CMsgClientLogon::set_cell_id(::google::protobuf::uint32 value) {
  set_has_cell_id();
  cell_id_ = value;
}

// optional uint32 last_session_id = 4;
inline bool CMsgClientLogon::has_last_session_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientLogon::set_has_last_session_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientLogon::clear_has_last_session_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientLogon::clear_last_session_id() {
  last_session_id_ = 0u;
  clear_has_last_session_id();
}
inline ::google::protobuf::uint32 CMsgClientLogon::last_session_id() const {
  return last_session_id_;
}
inline void CMsgClientLogon::set_last_session_id(::google::protobuf::uint32 value) {
  set_has_last_session_id();
  last_session_id_ = value;
}

// optional uint32 client_package_version = 5;
inline bool CMsgClientLogon::has_client_package_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientLogon::set_has_client_package_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientLogon::clear_has_client_package_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientLogon::clear_client_package_version() {
  client_package_version_ = 0u;
  clear_has_client_package_version();
}
inline ::google::protobuf::uint32 CMsgClientLogon::client_package_version() const {
  return client_package_version_;
}
inline void CMsgClientLogon::set_client_package_version(::google::protobuf::uint32 value) {
  set_has_client_package_version();
  client_package_version_ = value;
}

// optional string client_language = 6;
inline bool CMsgClientLogon::has_client_language() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientLogon::set_has_client_language() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientLogon::clear_has_client_language() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientLogon::clear_client_language() {
  if (client_language_ != &::google::protobuf::internal::kEmptyString) {
    client_language_->clear();
  }
  clear_has_client_language();
}
inline const ::std::string& CMsgClientLogon::client_language() const {
  return *client_language_;
}
inline void CMsgClientLogon::set_client_language(const ::std::string& value) {
  set_has_client_language();
  if (client_language_ == &::google::protobuf::internal::kEmptyString) {
    client_language_ = new ::std::string;
  }
  client_language_->assign(value);
}
inline void CMsgClientLogon::set_client_language(const char* value) {
  set_has_client_language();
  if (client_language_ == &::google::protobuf::internal::kEmptyString) {
    client_language_ = new ::std::string;
  }
  client_language_->assign(value);
}
inline void CMsgClientLogon::set_client_language(const char* value, size_t size) {
  set_has_client_language();
  if (client_language_ == &::google::protobuf::internal::kEmptyString) {
    client_language_ = new ::std::string;
  }
  client_language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_client_language() {
  set_has_client_language();
  if (client_language_ == &::google::protobuf::internal::kEmptyString) {
    client_language_ = new ::std::string;
  }
  return client_language_;
}
inline ::std::string* CMsgClientLogon::release_client_language() {
  clear_has_client_language();
  if (client_language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_language_;
    client_language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_client_language(::std::string* client_language) {
  if (client_language_ != &::google::protobuf::internal::kEmptyString) {
    delete client_language_;
  }
  if (client_language) {
    set_has_client_language();
    client_language_ = client_language;
  } else {
    clear_has_client_language();
    client_language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 client_os_type = 7;
inline bool CMsgClientLogon::has_client_os_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientLogon::set_has_client_os_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientLogon::clear_has_client_os_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientLogon::clear_client_os_type() {
  client_os_type_ = 0u;
  clear_has_client_os_type();
}
inline ::google::protobuf::uint32 CMsgClientLogon::client_os_type() const {
  return client_os_type_;
}
inline void CMsgClientLogon::set_client_os_type(::google::protobuf::uint32 value) {
  set_has_client_os_type();
  client_os_type_ = value;
}

// optional bool should_remember_password = 8 [default = false];
inline bool CMsgClientLogon::has_should_remember_password() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientLogon::set_has_should_remember_password() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientLogon::clear_has_should_remember_password() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientLogon::clear_should_remember_password() {
  should_remember_password_ = false;
  clear_has_should_remember_password();
}
inline bool CMsgClientLogon::should_remember_password() const {
  return should_remember_password_;
}
inline void CMsgClientLogon::set_should_remember_password(bool value) {
  set_has_should_remember_password();
  should_remember_password_ = value;
}

// optional string wine_version = 9;
inline bool CMsgClientLogon::has_wine_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientLogon::set_has_wine_version() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientLogon::clear_has_wine_version() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientLogon::clear_wine_version() {
  if (wine_version_ != &::google::protobuf::internal::kEmptyString) {
    wine_version_->clear();
  }
  clear_has_wine_version();
}
inline const ::std::string& CMsgClientLogon::wine_version() const {
  return *wine_version_;
}
inline void CMsgClientLogon::set_wine_version(const ::std::string& value) {
  set_has_wine_version();
  if (wine_version_ == &::google::protobuf::internal::kEmptyString) {
    wine_version_ = new ::std::string;
  }
  wine_version_->assign(value);
}
inline void CMsgClientLogon::set_wine_version(const char* value) {
  set_has_wine_version();
  if (wine_version_ == &::google::protobuf::internal::kEmptyString) {
    wine_version_ = new ::std::string;
  }
  wine_version_->assign(value);
}
inline void CMsgClientLogon::set_wine_version(const char* value, size_t size) {
  set_has_wine_version();
  if (wine_version_ == &::google::protobuf::internal::kEmptyString) {
    wine_version_ = new ::std::string;
  }
  wine_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_wine_version() {
  set_has_wine_version();
  if (wine_version_ == &::google::protobuf::internal::kEmptyString) {
    wine_version_ = new ::std::string;
  }
  return wine_version_;
}
inline ::std::string* CMsgClientLogon::release_wine_version() {
  clear_has_wine_version();
  if (wine_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wine_version_;
    wine_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_wine_version(::std::string* wine_version) {
  if (wine_version_ != &::google::protobuf::internal::kEmptyString) {
    delete wine_version_;
  }
  if (wine_version) {
    set_has_wine_version();
    wine_version_ = wine_version;
  } else {
    clear_has_wine_version();
    wine_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 deprecated_10 = 10;
inline bool CMsgClientLogon::has_deprecated_10() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientLogon::set_has_deprecated_10() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientLogon::clear_has_deprecated_10() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientLogon::clear_deprecated_10() {
  deprecated_10_ = 0u;
  clear_has_deprecated_10();
}
inline ::google::protobuf::uint32 CMsgClientLogon::deprecated_10() const {
  return deprecated_10_;
}
inline void CMsgClientLogon::set_deprecated_10(::google::protobuf::uint32 value) {
  set_has_deprecated_10();
  deprecated_10_ = value;
}

// optional .CMsgIPAddress obfuscated_private_ip = 11;
inline bool CMsgClientLogon::has_obfuscated_private_ip() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgClientLogon::set_has_obfuscated_private_ip() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgClientLogon::clear_has_obfuscated_private_ip() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgClientLogon::clear_obfuscated_private_ip() {
  if (obfuscated_private_ip_ != NULL) obfuscated_private_ip_->::CMsgIPAddress::Clear();
  clear_has_obfuscated_private_ip();
}
inline const ::CMsgIPAddress& CMsgClientLogon::obfuscated_private_ip() const {
  return obfuscated_private_ip_ != NULL ? *obfuscated_private_ip_ : *default_instance_->obfuscated_private_ip_;
}
inline ::CMsgIPAddress* CMsgClientLogon::mutable_obfuscated_private_ip() {
  set_has_obfuscated_private_ip();
  if (obfuscated_private_ip_ == NULL) obfuscated_private_ip_ = new ::CMsgIPAddress;
  return obfuscated_private_ip_;
}
inline ::CMsgIPAddress* CMsgClientLogon::release_obfuscated_private_ip() {
  clear_has_obfuscated_private_ip();
  ::CMsgIPAddress* temp = obfuscated_private_ip_;
  obfuscated_private_ip_ = NULL;
  return temp;
}
inline void CMsgClientLogon::set_allocated_obfuscated_private_ip(::CMsgIPAddress* obfuscated_private_ip) {
  delete obfuscated_private_ip_;
  obfuscated_private_ip_ = obfuscated_private_ip;
  if (obfuscated_private_ip) {
    set_has_obfuscated_private_ip();
  } else {
    clear_has_obfuscated_private_ip();
  }
}

// optional uint32 deprecated_public_ip = 20;
inline bool CMsgClientLogon::has_deprecated_public_ip() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgClientLogon::set_has_deprecated_public_ip() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgClientLogon::clear_has_deprecated_public_ip() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgClientLogon::clear_deprecated_public_ip() {
  deprecated_public_ip_ = 0u;
  clear_has_deprecated_public_ip();
}
inline ::google::protobuf::uint32 CMsgClientLogon::deprecated_public_ip() const {
  return deprecated_public_ip_;
}
inline void CMsgClientLogon::set_deprecated_public_ip(::google::protobuf::uint32 value) {
  set_has_deprecated_public_ip();
  deprecated_public_ip_ = value;
}

// optional uint32 qos_level = 21;
inline bool CMsgClientLogon::has_qos_level() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgClientLogon::set_has_qos_level() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CMsgClientLogon::clear_has_qos_level() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CMsgClientLogon::clear_qos_level() {
  qos_level_ = 0u;
  clear_has_qos_level();
}
inline ::google::protobuf::uint32 CMsgClientLogon::qos_level() const {
  return qos_level_;
}
inline void CMsgClientLogon::set_qos_level(::google::protobuf::uint32 value) {
  set_has_qos_level();
  qos_level_ = value;
}

// optional fixed64 client_supplied_steam_id = 22;
inline bool CMsgClientLogon::has_client_supplied_steam_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgClientLogon::set_has_client_supplied_steam_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CMsgClientLogon::clear_has_client_supplied_steam_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CMsgClientLogon::clear_client_supplied_steam_id() {
  client_supplied_steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_client_supplied_steam_id();
}
inline ::google::protobuf::uint64 CMsgClientLogon::client_supplied_steam_id() const {
  return client_supplied_steam_id_;
}
inline void CMsgClientLogon::set_client_supplied_steam_id(::google::protobuf::uint64 value) {
  set_has_client_supplied_steam_id();
  client_supplied_steam_id_ = value;
}

// optional .CMsgIPAddress public_ip = 23;
inline bool CMsgClientLogon::has_public_ip() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgClientLogon::set_has_public_ip() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CMsgClientLogon::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CMsgClientLogon::clear_public_ip() {
  if (public_ip_ != NULL) public_ip_->::CMsgIPAddress::Clear();
  clear_has_public_ip();
}
inline const ::CMsgIPAddress& CMsgClientLogon::public_ip() const {
  return public_ip_ != NULL ? *public_ip_ : *default_instance_->public_ip_;
}
inline ::CMsgIPAddress* CMsgClientLogon::mutable_public_ip() {
  set_has_public_ip();
  if (public_ip_ == NULL) public_ip_ = new ::CMsgIPAddress;
  return public_ip_;
}
inline ::CMsgIPAddress* CMsgClientLogon::release_public_ip() {
  clear_has_public_ip();
  ::CMsgIPAddress* temp = public_ip_;
  public_ip_ = NULL;
  return temp;
}
inline void CMsgClientLogon::set_allocated_public_ip(::CMsgIPAddress* public_ip) {
  delete public_ip_;
  public_ip_ = public_ip;
  if (public_ip) {
    set_has_public_ip();
  } else {
    clear_has_public_ip();
  }
}

// optional bytes machine_id = 30;
inline bool CMsgClientLogon::has_machine_id() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CMsgClientLogon::set_has_machine_id() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CMsgClientLogon::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CMsgClientLogon::clear_machine_id() {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    machine_id_->clear();
  }
  clear_has_machine_id();
}
inline const ::std::string& CMsgClientLogon::machine_id() const {
  return *machine_id_;
}
inline void CMsgClientLogon::set_machine_id(const ::std::string& value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void CMsgClientLogon::set_machine_id(const char* value) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void CMsgClientLogon::set_machine_id(const void* value, size_t size) {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_machine_id() {
  set_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}
inline ::std::string* CMsgClientLogon::release_machine_id() {
  clear_has_machine_id();
  if (machine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_id_;
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_machine_id(::std::string* machine_id) {
  if (machine_id_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_id_;
  }
  if (machine_id) {
    set_has_machine_id();
    machine_id_ = machine_id;
  } else {
    clear_has_machine_id();
    machine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 launcher_type = 31 [default = 0];
inline bool CMsgClientLogon::has_launcher_type() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CMsgClientLogon::set_has_launcher_type() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CMsgClientLogon::clear_has_launcher_type() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CMsgClientLogon::clear_launcher_type() {
  launcher_type_ = 0u;
  clear_has_launcher_type();
}
inline ::google::protobuf::uint32 CMsgClientLogon::launcher_type() const {
  return launcher_type_;
}
inline void CMsgClientLogon::set_launcher_type(::google::protobuf::uint32 value) {
  set_has_launcher_type();
  launcher_type_ = value;
}

// optional uint32 ui_mode = 32 [default = 0];
inline bool CMsgClientLogon::has_ui_mode() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CMsgClientLogon::set_has_ui_mode() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CMsgClientLogon::clear_has_ui_mode() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CMsgClientLogon::clear_ui_mode() {
  ui_mode_ = 0u;
  clear_has_ui_mode();
}
inline ::google::protobuf::uint32 CMsgClientLogon::ui_mode() const {
  return ui_mode_;
}
inline void CMsgClientLogon::set_ui_mode(::google::protobuf::uint32 value) {
  set_has_ui_mode();
  ui_mode_ = value;
}

// optional uint32 chat_mode = 33 [default = 0];
inline bool CMsgClientLogon::has_chat_mode() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CMsgClientLogon::set_has_chat_mode() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CMsgClientLogon::clear_has_chat_mode() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CMsgClientLogon::clear_chat_mode() {
  chat_mode_ = 0u;
  clear_has_chat_mode();
}
inline ::google::protobuf::uint32 CMsgClientLogon::chat_mode() const {
  return chat_mode_;
}
inline void CMsgClientLogon::set_chat_mode(::google::protobuf::uint32 value) {
  set_has_chat_mode();
  chat_mode_ = value;
}

// optional bytes steam2_auth_ticket = 41;
inline bool CMsgClientLogon::has_steam2_auth_ticket() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CMsgClientLogon::set_has_steam2_auth_ticket() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CMsgClientLogon::clear_has_steam2_auth_ticket() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CMsgClientLogon::clear_steam2_auth_ticket() {
  if (steam2_auth_ticket_ != &::google::protobuf::internal::kEmptyString) {
    steam2_auth_ticket_->clear();
  }
  clear_has_steam2_auth_ticket();
}
inline const ::std::string& CMsgClientLogon::steam2_auth_ticket() const {
  return *steam2_auth_ticket_;
}
inline void CMsgClientLogon::set_steam2_auth_ticket(const ::std::string& value) {
  set_has_steam2_auth_ticket();
  if (steam2_auth_ticket_ == &::google::protobuf::internal::kEmptyString) {
    steam2_auth_ticket_ = new ::std::string;
  }
  steam2_auth_ticket_->assign(value);
}
inline void CMsgClientLogon::set_steam2_auth_ticket(const char* value) {
  set_has_steam2_auth_ticket();
  if (steam2_auth_ticket_ == &::google::protobuf::internal::kEmptyString) {
    steam2_auth_ticket_ = new ::std::string;
  }
  steam2_auth_ticket_->assign(value);
}
inline void CMsgClientLogon::set_steam2_auth_ticket(const void* value, size_t size) {
  set_has_steam2_auth_ticket();
  if (steam2_auth_ticket_ == &::google::protobuf::internal::kEmptyString) {
    steam2_auth_ticket_ = new ::std::string;
  }
  steam2_auth_ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_steam2_auth_ticket() {
  set_has_steam2_auth_ticket();
  if (steam2_auth_ticket_ == &::google::protobuf::internal::kEmptyString) {
    steam2_auth_ticket_ = new ::std::string;
  }
  return steam2_auth_ticket_;
}
inline ::std::string* CMsgClientLogon::release_steam2_auth_ticket() {
  clear_has_steam2_auth_ticket();
  if (steam2_auth_ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = steam2_auth_ticket_;
    steam2_auth_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_steam2_auth_ticket(::std::string* steam2_auth_ticket) {
  if (steam2_auth_ticket_ != &::google::protobuf::internal::kEmptyString) {
    delete steam2_auth_ticket_;
  }
  if (steam2_auth_ticket) {
    set_has_steam2_auth_ticket();
    steam2_auth_ticket_ = steam2_auth_ticket;
  } else {
    clear_has_steam2_auth_ticket();
    steam2_auth_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email_address = 42;
inline bool CMsgClientLogon::has_email_address() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CMsgClientLogon::set_has_email_address() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CMsgClientLogon::clear_has_email_address() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CMsgClientLogon::clear_email_address() {
  if (email_address_ != &::google::protobuf::internal::kEmptyString) {
    email_address_->clear();
  }
  clear_has_email_address();
}
inline const ::std::string& CMsgClientLogon::email_address() const {
  return *email_address_;
}
inline void CMsgClientLogon::set_email_address(const ::std::string& value) {
  set_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    email_address_ = new ::std::string;
  }
  email_address_->assign(value);
}
inline void CMsgClientLogon::set_email_address(const char* value) {
  set_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    email_address_ = new ::std::string;
  }
  email_address_->assign(value);
}
inline void CMsgClientLogon::set_email_address(const char* value, size_t size) {
  set_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    email_address_ = new ::std::string;
  }
  email_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_email_address() {
  set_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    email_address_ = new ::std::string;
  }
  return email_address_;
}
inline ::std::string* CMsgClientLogon::release_email_address() {
  clear_has_email_address();
  if (email_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_address_;
    email_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_email_address(::std::string* email_address) {
  if (email_address_ != &::google::protobuf::internal::kEmptyString) {
    delete email_address_;
  }
  if (email_address) {
    set_has_email_address();
    email_address_ = email_address;
  } else {
    clear_has_email_address();
    email_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 rtime32_account_creation = 43;
inline bool CMsgClientLogon::has_rtime32_account_creation() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CMsgClientLogon::set_has_rtime32_account_creation() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CMsgClientLogon::clear_has_rtime32_account_creation() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CMsgClientLogon::clear_rtime32_account_creation() {
  rtime32_account_creation_ = 0u;
  clear_has_rtime32_account_creation();
}
inline ::google::protobuf::uint32 CMsgClientLogon::rtime32_account_creation() const {
  return rtime32_account_creation_;
}
inline void CMsgClientLogon::set_rtime32_account_creation(::google::protobuf::uint32 value) {
  set_has_rtime32_account_creation();
  rtime32_account_creation_ = value;
}

// optional string account_name = 50;
inline bool CMsgClientLogon::has_account_name() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CMsgClientLogon::set_has_account_name() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CMsgClientLogon::clear_has_account_name() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CMsgClientLogon::clear_account_name() {
  if (account_name_ != &::google::protobuf::internal::kEmptyString) {
    account_name_->clear();
  }
  clear_has_account_name();
}
inline const ::std::string& CMsgClientLogon::account_name() const {
  return *account_name_;
}
inline void CMsgClientLogon::set_account_name(const ::std::string& value) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(value);
}
inline void CMsgClientLogon::set_account_name(const char* value) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(value);
}
inline void CMsgClientLogon::set_account_name(const char* value, size_t size) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_account_name() {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  return account_name_;
}
inline ::std::string* CMsgClientLogon::release_account_name() {
  clear_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_name_;
    account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_account_name(::std::string* account_name) {
  if (account_name_ != &::google::protobuf::internal::kEmptyString) {
    delete account_name_;
  }
  if (account_name) {
    set_has_account_name();
    account_name_ = account_name;
  } else {
    clear_has_account_name();
    account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 51;
inline bool CMsgClientLogon::has_password() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CMsgClientLogon::set_has_password() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CMsgClientLogon::clear_has_password() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CMsgClientLogon::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CMsgClientLogon::password() const {
  return *password_;
}
inline void CMsgClientLogon::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CMsgClientLogon::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CMsgClientLogon::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* CMsgClientLogon::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string game_server_token = 52;
inline bool CMsgClientLogon::has_game_server_token() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CMsgClientLogon::set_has_game_server_token() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CMsgClientLogon::clear_has_game_server_token() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CMsgClientLogon::clear_game_server_token() {
  if (game_server_token_ != &::google::protobuf::internal::kEmptyString) {
    game_server_token_->clear();
  }
  clear_has_game_server_token();
}
inline const ::std::string& CMsgClientLogon::game_server_token() const {
  return *game_server_token_;
}
inline void CMsgClientLogon::set_game_server_token(const ::std::string& value) {
  set_has_game_server_token();
  if (game_server_token_ == &::google::protobuf::internal::kEmptyString) {
    game_server_token_ = new ::std::string;
  }
  game_server_token_->assign(value);
}
inline void CMsgClientLogon::set_game_server_token(const char* value) {
  set_has_game_server_token();
  if (game_server_token_ == &::google::protobuf::internal::kEmptyString) {
    game_server_token_ = new ::std::string;
  }
  game_server_token_->assign(value);
}
inline void CMsgClientLogon::set_game_server_token(const char* value, size_t size) {
  set_has_game_server_token();
  if (game_server_token_ == &::google::protobuf::internal::kEmptyString) {
    game_server_token_ = new ::std::string;
  }
  game_server_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_game_server_token() {
  set_has_game_server_token();
  if (game_server_token_ == &::google::protobuf::internal::kEmptyString) {
    game_server_token_ = new ::std::string;
  }
  return game_server_token_;
}
inline ::std::string* CMsgClientLogon::release_game_server_token() {
  clear_has_game_server_token();
  if (game_server_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = game_server_token_;
    game_server_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_game_server_token(::std::string* game_server_token) {
  if (game_server_token_ != &::google::protobuf::internal::kEmptyString) {
    delete game_server_token_;
  }
  if (game_server_token) {
    set_has_game_server_token();
    game_server_token_ = game_server_token;
  } else {
    clear_has_game_server_token();
    game_server_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string login_key = 60;
inline bool CMsgClientLogon::has_login_key() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CMsgClientLogon::set_has_login_key() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CMsgClientLogon::clear_has_login_key() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CMsgClientLogon::clear_login_key() {
  if (login_key_ != &::google::protobuf::internal::kEmptyString) {
    login_key_->clear();
  }
  clear_has_login_key();
}
inline const ::std::string& CMsgClientLogon::login_key() const {
  return *login_key_;
}
inline void CMsgClientLogon::set_login_key(const ::std::string& value) {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  login_key_->assign(value);
}
inline void CMsgClientLogon::set_login_key(const char* value) {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  login_key_->assign(value);
}
inline void CMsgClientLogon::set_login_key(const char* value, size_t size) {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  login_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_login_key() {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  return login_key_;
}
inline ::std::string* CMsgClientLogon::release_login_key() {
  clear_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = login_key_;
    login_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_login_key(::std::string* login_key) {
  if (login_key_ != &::google::protobuf::internal::kEmptyString) {
    delete login_key_;
  }
  if (login_key) {
    set_has_login_key();
    login_key_ = login_key;
  } else {
    clear_has_login_key();
    login_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool was_converted_deprecated_msg = 70 [default = false];
inline bool CMsgClientLogon::has_was_converted_deprecated_msg() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void CMsgClientLogon::set_has_was_converted_deprecated_msg() {
  _has_bits_[0] |= 0x04000000u;
}
inline void CMsgClientLogon::clear_has_was_converted_deprecated_msg() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void CMsgClientLogon::clear_was_converted_deprecated_msg() {
  was_converted_deprecated_msg_ = false;
  clear_has_was_converted_deprecated_msg();
}
inline bool CMsgClientLogon::was_converted_deprecated_msg() const {
  return was_converted_deprecated_msg_;
}
inline void CMsgClientLogon::set_was_converted_deprecated_msg(bool value) {
  set_has_was_converted_deprecated_msg();
  was_converted_deprecated_msg_ = value;
}

// optional string anon_user_target_account_name = 80;
inline bool CMsgClientLogon::has_anon_user_target_account_name() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void CMsgClientLogon::set_has_anon_user_target_account_name() {
  _has_bits_[0] |= 0x08000000u;
}
inline void CMsgClientLogon::clear_has_anon_user_target_account_name() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void CMsgClientLogon::clear_anon_user_target_account_name() {
  if (anon_user_target_account_name_ != &::google::protobuf::internal::kEmptyString) {
    anon_user_target_account_name_->clear();
  }
  clear_has_anon_user_target_account_name();
}
inline const ::std::string& CMsgClientLogon::anon_user_target_account_name() const {
  return *anon_user_target_account_name_;
}
inline void CMsgClientLogon::set_anon_user_target_account_name(const ::std::string& value) {
  set_has_anon_user_target_account_name();
  if (anon_user_target_account_name_ == &::google::protobuf::internal::kEmptyString) {
    anon_user_target_account_name_ = new ::std::string;
  }
  anon_user_target_account_name_->assign(value);
}
inline void CMsgClientLogon::set_anon_user_target_account_name(const char* value) {
  set_has_anon_user_target_account_name();
  if (anon_user_target_account_name_ == &::google::protobuf::internal::kEmptyString) {
    anon_user_target_account_name_ = new ::std::string;
  }
  anon_user_target_account_name_->assign(value);
}
inline void CMsgClientLogon::set_anon_user_target_account_name(const char* value, size_t size) {
  set_has_anon_user_target_account_name();
  if (anon_user_target_account_name_ == &::google::protobuf::internal::kEmptyString) {
    anon_user_target_account_name_ = new ::std::string;
  }
  anon_user_target_account_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_anon_user_target_account_name() {
  set_has_anon_user_target_account_name();
  if (anon_user_target_account_name_ == &::google::protobuf::internal::kEmptyString) {
    anon_user_target_account_name_ = new ::std::string;
  }
  return anon_user_target_account_name_;
}
inline ::std::string* CMsgClientLogon::release_anon_user_target_account_name() {
  clear_has_anon_user_target_account_name();
  if (anon_user_target_account_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = anon_user_target_account_name_;
    anon_user_target_account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_anon_user_target_account_name(::std::string* anon_user_target_account_name) {
  if (anon_user_target_account_name_ != &::google::protobuf::internal::kEmptyString) {
    delete anon_user_target_account_name_;
  }
  if (anon_user_target_account_name) {
    set_has_anon_user_target_account_name();
    anon_user_target_account_name_ = anon_user_target_account_name;
  } else {
    clear_has_anon_user_target_account_name();
    anon_user_target_account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed64 resolved_user_steam_id = 81;
inline bool CMsgClientLogon::has_resolved_user_steam_id() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void CMsgClientLogon::set_has_resolved_user_steam_id() {
  _has_bits_[0] |= 0x10000000u;
}
inline void CMsgClientLogon::clear_has_resolved_user_steam_id() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void CMsgClientLogon::clear_resolved_user_steam_id() {
  resolved_user_steam_id_ = GOOGLE_ULONGLONG(0);
  clear_has_resolved_user_steam_id();
}
inline ::google::protobuf::uint64 CMsgClientLogon::resolved_user_steam_id() const {
  return resolved_user_steam_id_;
}
inline void CMsgClientLogon::set_resolved_user_steam_id(::google::protobuf::uint64 value) {
  set_has_resolved_user_steam_id();
  resolved_user_steam_id_ = value;
}

// optional int32 eresult_sentryfile = 82;
inline bool CMsgClientLogon::has_eresult_sentryfile() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void CMsgClientLogon::set_has_eresult_sentryfile() {
  _has_bits_[0] |= 0x20000000u;
}
inline void CMsgClientLogon::clear_has_eresult_sentryfile() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void CMsgClientLogon::clear_eresult_sentryfile() {
  eresult_sentryfile_ = 0;
  clear_has_eresult_sentryfile();
}
inline ::google::protobuf::int32 CMsgClientLogon::eresult_sentryfile() const {
  return eresult_sentryfile_;
}
inline void CMsgClientLogon::set_eresult_sentryfile(::google::protobuf::int32 value) {
  set_has_eresult_sentryfile();
  eresult_sentryfile_ = value;
}

// optional bytes sha_sentryfile = 83;
inline bool CMsgClientLogon::has_sha_sentryfile() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void CMsgClientLogon::set_has_sha_sentryfile() {
  _has_bits_[0] |= 0x40000000u;
}
inline void CMsgClientLogon::clear_has_sha_sentryfile() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void CMsgClientLogon::clear_sha_sentryfile() {
  if (sha_sentryfile_ != &::google::protobuf::internal::kEmptyString) {
    sha_sentryfile_->clear();
  }
  clear_has_sha_sentryfile();
}
inline const ::std::string& CMsgClientLogon::sha_sentryfile() const {
  return *sha_sentryfile_;
}
inline void CMsgClientLogon::set_sha_sentryfile(const ::std::string& value) {
  set_has_sha_sentryfile();
  if (sha_sentryfile_ == &::google::protobuf::internal::kEmptyString) {
    sha_sentryfile_ = new ::std::string;
  }
  sha_sentryfile_->assign(value);
}
inline void CMsgClientLogon::set_sha_sentryfile(const char* value) {
  set_has_sha_sentryfile();
  if (sha_sentryfile_ == &::google::protobuf::internal::kEmptyString) {
    sha_sentryfile_ = new ::std::string;
  }
  sha_sentryfile_->assign(value);
}
inline void CMsgClientLogon::set_sha_sentryfile(const void* value, size_t size) {
  set_has_sha_sentryfile();
  if (sha_sentryfile_ == &::google::protobuf::internal::kEmptyString) {
    sha_sentryfile_ = new ::std::string;
  }
  sha_sentryfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_sha_sentryfile() {
  set_has_sha_sentryfile();
  if (sha_sentryfile_ == &::google::protobuf::internal::kEmptyString) {
    sha_sentryfile_ = new ::std::string;
  }
  return sha_sentryfile_;
}
inline ::std::string* CMsgClientLogon::release_sha_sentryfile() {
  clear_has_sha_sentryfile();
  if (sha_sentryfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha_sentryfile_;
    sha_sentryfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_sha_sentryfile(::std::string* sha_sentryfile) {
  if (sha_sentryfile_ != &::google::protobuf::internal::kEmptyString) {
    delete sha_sentryfile_;
  }
  if (sha_sentryfile) {
    set_has_sha_sentryfile();
    sha_sentryfile_ = sha_sentryfile;
  } else {
    clear_has_sha_sentryfile();
    sha_sentryfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string auth_code = 84;
inline bool CMsgClientLogon::has_auth_code() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void CMsgClientLogon::set_has_auth_code() {
  _has_bits_[0] |= 0x80000000u;
}
inline void CMsgClientLogon::clear_has_auth_code() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void CMsgClientLogon::clear_auth_code() {
  if (auth_code_ != &::google::protobuf::internal::kEmptyString) {
    auth_code_->clear();
  }
  clear_has_auth_code();
}
inline const ::std::string& CMsgClientLogon::auth_code() const {
  return *auth_code_;
}
inline void CMsgClientLogon::set_auth_code(const ::std::string& value) {
  set_has_auth_code();
  if (auth_code_ == &::google::protobuf::internal::kEmptyString) {
    auth_code_ = new ::std::string;
  }
  auth_code_->assign(value);
}
inline void CMsgClientLogon::set_auth_code(const char* value) {
  set_has_auth_code();
  if (auth_code_ == &::google::protobuf::internal::kEmptyString) {
    auth_code_ = new ::std::string;
  }
  auth_code_->assign(value);
}
inline void CMsgClientLogon::set_auth_code(const char* value, size_t size) {
  set_has_auth_code();
  if (auth_code_ == &::google::protobuf::internal::kEmptyString) {
    auth_code_ = new ::std::string;
  }
  auth_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_auth_code() {
  set_has_auth_code();
  if (auth_code_ == &::google::protobuf::internal::kEmptyString) {
    auth_code_ = new ::std::string;
  }
  return auth_code_;
}
inline ::std::string* CMsgClientLogon::release_auth_code() {
  clear_has_auth_code();
  if (auth_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_code_;
    auth_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_auth_code(::std::string* auth_code) {
  if (auth_code_ != &::google::protobuf::internal::kEmptyString) {
    delete auth_code_;
  }
  if (auth_code) {
    set_has_auth_code();
    auth_code_ = auth_code;
  } else {
    clear_has_auth_code();
    auth_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 otp_type = 85;
inline bool CMsgClientLogon::has_otp_type() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void CMsgClientLogon::set_has_otp_type() {
  _has_bits_[1] |= 0x00000001u;
}
inline void CMsgClientLogon::clear_has_otp_type() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void CMsgClientLogon::clear_otp_type() {
  otp_type_ = 0;
  clear_has_otp_type();
}
inline ::google::protobuf::int32 CMsgClientLogon::otp_type() const {
  return otp_type_;
}
inline void CMsgClientLogon::set_otp_type(::google::protobuf::int32 value) {
  set_has_otp_type();
  otp_type_ = value;
}

// optional uint32 otp_value = 86;
inline bool CMsgClientLogon::has_otp_value() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void CMsgClientLogon::set_has_otp_value() {
  _has_bits_[1] |= 0x00000002u;
}
inline void CMsgClientLogon::clear_has_otp_value() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void CMsgClientLogon::clear_otp_value() {
  otp_value_ = 0u;
  clear_has_otp_value();
}
inline ::google::protobuf::uint32 CMsgClientLogon::otp_value() const {
  return otp_value_;
}
inline void CMsgClientLogon::set_otp_value(::google::protobuf::uint32 value) {
  set_has_otp_value();
  otp_value_ = value;
}

// optional string otp_identifier = 87;
inline bool CMsgClientLogon::has_otp_identifier() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void CMsgClientLogon::set_has_otp_identifier() {
  _has_bits_[1] |= 0x00000004u;
}
inline void CMsgClientLogon::clear_has_otp_identifier() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void CMsgClientLogon::clear_otp_identifier() {
  if (otp_identifier_ != &::google::protobuf::internal::kEmptyString) {
    otp_identifier_->clear();
  }
  clear_has_otp_identifier();
}
inline const ::std::string& CMsgClientLogon::otp_identifier() const {
  return *otp_identifier_;
}
inline void CMsgClientLogon::set_otp_identifier(const ::std::string& value) {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  otp_identifier_->assign(value);
}
inline void CMsgClientLogon::set_otp_identifier(const char* value) {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  otp_identifier_->assign(value);
}
inline void CMsgClientLogon::set_otp_identifier(const char* value, size_t size) {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  otp_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_otp_identifier() {
  set_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    otp_identifier_ = new ::std::string;
  }
  return otp_identifier_;
}
inline ::std::string* CMsgClientLogon::release_otp_identifier() {
  clear_has_otp_identifier();
  if (otp_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = otp_identifier_;
    otp_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_otp_identifier(::std::string* otp_identifier) {
  if (otp_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete otp_identifier_;
  }
  if (otp_identifier) {
    set_has_otp_identifier();
    otp_identifier_ = otp_identifier;
  } else {
    clear_has_otp_identifier();
    otp_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool steam2_ticket_request = 88;
inline bool CMsgClientLogon::has_steam2_ticket_request() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void CMsgClientLogon::set_has_steam2_ticket_request() {
  _has_bits_[1] |= 0x00000008u;
}
inline void CMsgClientLogon::clear_has_steam2_ticket_request() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void CMsgClientLogon::clear_steam2_ticket_request() {
  steam2_ticket_request_ = false;
  clear_has_steam2_ticket_request();
}
inline bool CMsgClientLogon::steam2_ticket_request() const {
  return steam2_ticket_request_;
}
inline void CMsgClientLogon::set_steam2_ticket_request(bool value) {
  set_has_steam2_ticket_request();
  steam2_ticket_request_ = value;
}

// optional bytes sony_psn_ticket = 90;
inline bool CMsgClientLogon::has_sony_psn_ticket() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void CMsgClientLogon::set_has_sony_psn_ticket() {
  _has_bits_[1] |= 0x00000010u;
}
inline void CMsgClientLogon::clear_has_sony_psn_ticket() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void CMsgClientLogon::clear_sony_psn_ticket() {
  if (sony_psn_ticket_ != &::google::protobuf::internal::kEmptyString) {
    sony_psn_ticket_->clear();
  }
  clear_has_sony_psn_ticket();
}
inline const ::std::string& CMsgClientLogon::sony_psn_ticket() const {
  return *sony_psn_ticket_;
}
inline void CMsgClientLogon::set_sony_psn_ticket(const ::std::string& value) {
  set_has_sony_psn_ticket();
  if (sony_psn_ticket_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_ticket_ = new ::std::string;
  }
  sony_psn_ticket_->assign(value);
}
inline void CMsgClientLogon::set_sony_psn_ticket(const char* value) {
  set_has_sony_psn_ticket();
  if (sony_psn_ticket_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_ticket_ = new ::std::string;
  }
  sony_psn_ticket_->assign(value);
}
inline void CMsgClientLogon::set_sony_psn_ticket(const void* value, size_t size) {
  set_has_sony_psn_ticket();
  if (sony_psn_ticket_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_ticket_ = new ::std::string;
  }
  sony_psn_ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_sony_psn_ticket() {
  set_has_sony_psn_ticket();
  if (sony_psn_ticket_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_ticket_ = new ::std::string;
  }
  return sony_psn_ticket_;
}
inline ::std::string* CMsgClientLogon::release_sony_psn_ticket() {
  clear_has_sony_psn_ticket();
  if (sony_psn_ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sony_psn_ticket_;
    sony_psn_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_sony_psn_ticket(::std::string* sony_psn_ticket) {
  if (sony_psn_ticket_ != &::google::protobuf::internal::kEmptyString) {
    delete sony_psn_ticket_;
  }
  if (sony_psn_ticket) {
    set_has_sony_psn_ticket();
    sony_psn_ticket_ = sony_psn_ticket;
  } else {
    clear_has_sony_psn_ticket();
    sony_psn_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sony_psn_service_id = 91;
inline bool CMsgClientLogon::has_sony_psn_service_id() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void CMsgClientLogon::set_has_sony_psn_service_id() {
  _has_bits_[1] |= 0x00000020u;
}
inline void CMsgClientLogon::clear_has_sony_psn_service_id() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void CMsgClientLogon::clear_sony_psn_service_id() {
  if (sony_psn_service_id_ != &::google::protobuf::internal::kEmptyString) {
    sony_psn_service_id_->clear();
  }
  clear_has_sony_psn_service_id();
}
inline const ::std::string& CMsgClientLogon::sony_psn_service_id() const {
  return *sony_psn_service_id_;
}
inline void CMsgClientLogon::set_sony_psn_service_id(const ::std::string& value) {
  set_has_sony_psn_service_id();
  if (sony_psn_service_id_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_service_id_ = new ::std::string;
  }
  sony_psn_service_id_->assign(value);
}
inline void CMsgClientLogon::set_sony_psn_service_id(const char* value) {
  set_has_sony_psn_service_id();
  if (sony_psn_service_id_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_service_id_ = new ::std::string;
  }
  sony_psn_service_id_->assign(value);
}
inline void CMsgClientLogon::set_sony_psn_service_id(const char* value, size_t size) {
  set_has_sony_psn_service_id();
  if (sony_psn_service_id_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_service_id_ = new ::std::string;
  }
  sony_psn_service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_sony_psn_service_id() {
  set_has_sony_psn_service_id();
  if (sony_psn_service_id_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_service_id_ = new ::std::string;
  }
  return sony_psn_service_id_;
}
inline ::std::string* CMsgClientLogon::release_sony_psn_service_id() {
  clear_has_sony_psn_service_id();
  if (sony_psn_service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sony_psn_service_id_;
    sony_psn_service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_sony_psn_service_id(::std::string* sony_psn_service_id) {
  if (sony_psn_service_id_ != &::google::protobuf::internal::kEmptyString) {
    delete sony_psn_service_id_;
  }
  if (sony_psn_service_id) {
    set_has_sony_psn_service_id();
    sony_psn_service_id_ = sony_psn_service_id;
  } else {
    clear_has_sony_psn_service_id();
    sony_psn_service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool create_new_psn_linked_account_if_needed = 92 [default = false];
inline bool CMsgClientLogon::has_create_new_psn_linked_account_if_needed() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void CMsgClientLogon::set_has_create_new_psn_linked_account_if_needed() {
  _has_bits_[1] |= 0x00000040u;
}
inline void CMsgClientLogon::clear_has_create_new_psn_linked_account_if_needed() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void CMsgClientLogon::clear_create_new_psn_linked_account_if_needed() {
  create_new_psn_linked_account_if_needed_ = false;
  clear_has_create_new_psn_linked_account_if_needed();
}
inline bool CMsgClientLogon::create_new_psn_linked_account_if_needed() const {
  return create_new_psn_linked_account_if_needed_;
}
inline void CMsgClientLogon::set_create_new_psn_linked_account_if_needed(bool value) {
  set_has_create_new_psn_linked_account_if_needed();
  create_new_psn_linked_account_if_needed_ = value;
}

// optional string sony_psn_name = 93;
inline bool CMsgClientLogon::has_sony_psn_name() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void CMsgClientLogon::set_has_sony_psn_name() {
  _has_bits_[1] |= 0x00000080u;
}
inline void CMsgClientLogon::clear_has_sony_psn_name() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void CMsgClientLogon::clear_sony_psn_name() {
  if (sony_psn_name_ != &::google::protobuf::internal::kEmptyString) {
    sony_psn_name_->clear();
  }
  clear_has_sony_psn_name();
}
inline const ::std::string& CMsgClientLogon::sony_psn_name() const {
  return *sony_psn_name_;
}
inline void CMsgClientLogon::set_sony_psn_name(const ::std::string& value) {
  set_has_sony_psn_name();
  if (sony_psn_name_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_name_ = new ::std::string;
  }
  sony_psn_name_->assign(value);
}
inline void CMsgClientLogon::set_sony_psn_name(const char* value) {
  set_has_sony_psn_name();
  if (sony_psn_name_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_name_ = new ::std::string;
  }
  sony_psn_name_->assign(value);
}
inline void CMsgClientLogon::set_sony_psn_name(const char* value, size_t size) {
  set_has_sony_psn_name();
  if (sony_psn_name_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_name_ = new ::std::string;
  }
  sony_psn_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_sony_psn_name() {
  set_has_sony_psn_name();
  if (sony_psn_name_ == &::google::protobuf::internal::kEmptyString) {
    sony_psn_name_ = new ::std::string;
  }
  return sony_psn_name_;
}
inline ::std::string* CMsgClientLogon::release_sony_psn_name() {
  clear_has_sony_psn_name();
  if (sony_psn_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sony_psn_name_;
    sony_psn_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_sony_psn_name(::std::string* sony_psn_name) {
  if (sony_psn_name_ != &::google::protobuf::internal::kEmptyString) {
    delete sony_psn_name_;
  }
  if (sony_psn_name) {
    set_has_sony_psn_name();
    sony_psn_name_ = sony_psn_name;
  } else {
    clear_has_sony_psn_name();
    sony_psn_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 game_server_app_id = 94;
inline bool CMsgClientLogon::has_game_server_app_id() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void CMsgClientLogon::set_has_game_server_app_id() {
  _has_bits_[1] |= 0x00000100u;
}
inline void CMsgClientLogon::clear_has_game_server_app_id() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void CMsgClientLogon::clear_game_server_app_id() {
  game_server_app_id_ = 0;
  clear_has_game_server_app_id();
}
inline ::google::protobuf::int32 CMsgClientLogon::game_server_app_id() const {
  return game_server_app_id_;
}
inline void CMsgClientLogon::set_game_server_app_id(::google::protobuf::int32 value) {
  set_has_game_server_app_id();
  game_server_app_id_ = value;
}

// optional bool steamguard_dont_remember_computer = 95;
inline bool CMsgClientLogon::has_steamguard_dont_remember_computer() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void CMsgClientLogon::set_has_steamguard_dont_remember_computer() {
  _has_bits_[1] |= 0x00000200u;
}
inline void CMsgClientLogon::clear_has_steamguard_dont_remember_computer() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void CMsgClientLogon::clear_steamguard_dont_remember_computer() {
  steamguard_dont_remember_computer_ = false;
  clear_has_steamguard_dont_remember_computer();
}
inline bool CMsgClientLogon::steamguard_dont_remember_computer() const {
  return steamguard_dont_remember_computer_;
}
inline void CMsgClientLogon::set_steamguard_dont_remember_computer(bool value) {
  set_has_steamguard_dont_remember_computer();
  steamguard_dont_remember_computer_ = value;
}

// optional string machine_name = 96;
inline bool CMsgClientLogon::has_machine_name() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void CMsgClientLogon::set_has_machine_name() {
  _has_bits_[1] |= 0x00000400u;
}
inline void CMsgClientLogon::clear_has_machine_name() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void CMsgClientLogon::clear_machine_name() {
  if (machine_name_ != &::google::protobuf::internal::kEmptyString) {
    machine_name_->clear();
  }
  clear_has_machine_name();
}
inline const ::std::string& CMsgClientLogon::machine_name() const {
  return *machine_name_;
}
inline void CMsgClientLogon::set_machine_name(const ::std::string& value) {
  set_has_machine_name();
  if (machine_name_ == &::google::protobuf::internal::kEmptyString) {
    machine_name_ = new ::std::string;
  }
  machine_name_->assign(value);
}
inline void CMsgClientLogon::set_machine_name(const char* value) {
  set_has_machine_name();
  if (machine_name_ == &::google::protobuf::internal::kEmptyString) {
    machine_name_ = new ::std::string;
  }
  machine_name_->assign(value);
}
inline void CMsgClientLogon::set_machine_name(const char* value, size_t size) {
  set_has_machine_name();
  if (machine_name_ == &::google::protobuf::internal::kEmptyString) {
    machine_name_ = new ::std::string;
  }
  machine_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_machine_name() {
  set_has_machine_name();
  if (machine_name_ == &::google::protobuf::internal::kEmptyString) {
    machine_name_ = new ::std::string;
  }
  return machine_name_;
}
inline ::std::string* CMsgClientLogon::release_machine_name() {
  clear_has_machine_name();
  if (machine_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_name_;
    machine_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_machine_name(::std::string* machine_name) {
  if (machine_name_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_name_;
  }
  if (machine_name) {
    set_has_machine_name();
    machine_name_ = machine_name;
  } else {
    clear_has_machine_name();
    machine_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string machine_name_userchosen = 97;
inline bool CMsgClientLogon::has_machine_name_userchosen() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void CMsgClientLogon::set_has_machine_name_userchosen() {
  _has_bits_[1] |= 0x00000800u;
}
inline void CMsgClientLogon::clear_has_machine_name_userchosen() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void CMsgClientLogon::clear_machine_name_userchosen() {
  if (machine_name_userchosen_ != &::google::protobuf::internal::kEmptyString) {
    machine_name_userchosen_->clear();
  }
  clear_has_machine_name_userchosen();
}
inline const ::std::string& CMsgClientLogon::machine_name_userchosen() const {
  return *machine_name_userchosen_;
}
inline void CMsgClientLogon::set_machine_name_userchosen(const ::std::string& value) {
  set_has_machine_name_userchosen();
  if (machine_name_userchosen_ == &::google::protobuf::internal::kEmptyString) {
    machine_name_userchosen_ = new ::std::string;
  }
  machine_name_userchosen_->assign(value);
}
inline void CMsgClientLogon::set_machine_name_userchosen(const char* value) {
  set_has_machine_name_userchosen();
  if (machine_name_userchosen_ == &::google::protobuf::internal::kEmptyString) {
    machine_name_userchosen_ = new ::std::string;
  }
  machine_name_userchosen_->assign(value);
}
inline void CMsgClientLogon::set_machine_name_userchosen(const char* value, size_t size) {
  set_has_machine_name_userchosen();
  if (machine_name_userchosen_ == &::google::protobuf::internal::kEmptyString) {
    machine_name_userchosen_ = new ::std::string;
  }
  machine_name_userchosen_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_machine_name_userchosen() {
  set_has_machine_name_userchosen();
  if (machine_name_userchosen_ == &::google::protobuf::internal::kEmptyString) {
    machine_name_userchosen_ = new ::std::string;
  }
  return machine_name_userchosen_;
}
inline ::std::string* CMsgClientLogon::release_machine_name_userchosen() {
  clear_has_machine_name_userchosen();
  if (machine_name_userchosen_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machine_name_userchosen_;
    machine_name_userchosen_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_machine_name_userchosen(::std::string* machine_name_userchosen) {
  if (machine_name_userchosen_ != &::google::protobuf::internal::kEmptyString) {
    delete machine_name_userchosen_;
  }
  if (machine_name_userchosen) {
    set_has_machine_name_userchosen();
    machine_name_userchosen_ = machine_name_userchosen;
  } else {
    clear_has_machine_name_userchosen();
    machine_name_userchosen_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string country_override = 98;
inline bool CMsgClientLogon::has_country_override() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void CMsgClientLogon::set_has_country_override() {
  _has_bits_[1] |= 0x00001000u;
}
inline void CMsgClientLogon::clear_has_country_override() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void CMsgClientLogon::clear_country_override() {
  if (country_override_ != &::google::protobuf::internal::kEmptyString) {
    country_override_->clear();
  }
  clear_has_country_override();
}
inline const ::std::string& CMsgClientLogon::country_override() const {
  return *country_override_;
}
inline void CMsgClientLogon::set_country_override(const ::std::string& value) {
  set_has_country_override();
  if (country_override_ == &::google::protobuf::internal::kEmptyString) {
    country_override_ = new ::std::string;
  }
  country_override_->assign(value);
}
inline void CMsgClientLogon::set_country_override(const char* value) {
  set_has_country_override();
  if (country_override_ == &::google::protobuf::internal::kEmptyString) {
    country_override_ = new ::std::string;
  }
  country_override_->assign(value);
}
inline void CMsgClientLogon::set_country_override(const char* value, size_t size) {
  set_has_country_override();
  if (country_override_ == &::google::protobuf::internal::kEmptyString) {
    country_override_ = new ::std::string;
  }
  country_override_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_country_override() {
  set_has_country_override();
  if (country_override_ == &::google::protobuf::internal::kEmptyString) {
    country_override_ = new ::std::string;
  }
  return country_override_;
}
inline ::std::string* CMsgClientLogon::release_country_override() {
  clear_has_country_override();
  if (country_override_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_override_;
    country_override_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_country_override(::std::string* country_override) {
  if (country_override_ != &::google::protobuf::internal::kEmptyString) {
    delete country_override_;
  }
  if (country_override) {
    set_has_country_override();
    country_override_ = country_override;
  } else {
    clear_has_country_override();
    country_override_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_steam_box = 99;
inline bool CMsgClientLogon::has_is_steam_box() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void CMsgClientLogon::set_has_is_steam_box() {
  _has_bits_[1] |= 0x00002000u;
}
inline void CMsgClientLogon::clear_has_is_steam_box() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void CMsgClientLogon::clear_is_steam_box() {
  is_steam_box_ = false;
  clear_has_is_steam_box();
}
inline bool CMsgClientLogon::is_steam_box() const {
  return is_steam_box_;
}
inline void CMsgClientLogon::set_is_steam_box(bool value) {
  set_has_is_steam_box();
  is_steam_box_ = value;
}

// optional uint64 client_instance_id = 100;
inline bool CMsgClientLogon::has_client_instance_id() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void CMsgClientLogon::set_has_client_instance_id() {
  _has_bits_[1] |= 0x00004000u;
}
inline void CMsgClientLogon::clear_has_client_instance_id() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void CMsgClientLogon::clear_client_instance_id() {
  client_instance_id_ = GOOGLE_ULONGLONG(0);
  clear_has_client_instance_id();
}
inline ::google::protobuf::uint64 CMsgClientLogon::client_instance_id() const {
  return client_instance_id_;
}
inline void CMsgClientLogon::set_client_instance_id(::google::protobuf::uint64 value) {
  set_has_client_instance_id();
  client_instance_id_ = value;
}

// optional string two_factor_code = 101;
inline bool CMsgClientLogon::has_two_factor_code() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void CMsgClientLogon::set_has_two_factor_code() {
  _has_bits_[1] |= 0x00008000u;
}
inline void CMsgClientLogon::clear_has_two_factor_code() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void CMsgClientLogon::clear_two_factor_code() {
  if (two_factor_code_ != &::google::protobuf::internal::kEmptyString) {
    two_factor_code_->clear();
  }
  clear_has_two_factor_code();
}
inline const ::std::string& CMsgClientLogon::two_factor_code() const {
  return *two_factor_code_;
}
inline void CMsgClientLogon::set_two_factor_code(const ::std::string& value) {
  set_has_two_factor_code();
  if (two_factor_code_ == &::google::protobuf::internal::kEmptyString) {
    two_factor_code_ = new ::std::string;
  }
  two_factor_code_->assign(value);
}
inline void CMsgClientLogon::set_two_factor_code(const char* value) {
  set_has_two_factor_code();
  if (two_factor_code_ == &::google::protobuf::internal::kEmptyString) {
    two_factor_code_ = new ::std::string;
  }
  two_factor_code_->assign(value);
}
inline void CMsgClientLogon::set_two_factor_code(const char* value, size_t size) {
  set_has_two_factor_code();
  if (two_factor_code_ == &::google::protobuf::internal::kEmptyString) {
    two_factor_code_ = new ::std::string;
  }
  two_factor_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_two_factor_code() {
  set_has_two_factor_code();
  if (two_factor_code_ == &::google::protobuf::internal::kEmptyString) {
    two_factor_code_ = new ::std::string;
  }
  return two_factor_code_;
}
inline ::std::string* CMsgClientLogon::release_two_factor_code() {
  clear_has_two_factor_code();
  if (two_factor_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = two_factor_code_;
    two_factor_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_two_factor_code(::std::string* two_factor_code) {
  if (two_factor_code_ != &::google::protobuf::internal::kEmptyString) {
    delete two_factor_code_;
  }
  if (two_factor_code) {
    set_has_two_factor_code();
    two_factor_code_ = two_factor_code;
  } else {
    clear_has_two_factor_code();
    two_factor_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool supports_rate_limit_response = 102;
inline bool CMsgClientLogon::has_supports_rate_limit_response() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void CMsgClientLogon::set_has_supports_rate_limit_response() {
  _has_bits_[1] |= 0x00010000u;
}
inline void CMsgClientLogon::clear_has_supports_rate_limit_response() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void CMsgClientLogon::clear_supports_rate_limit_response() {
  supports_rate_limit_response_ = false;
  clear_has_supports_rate_limit_response();
}
inline bool CMsgClientLogon::supports_rate_limit_response() const {
  return supports_rate_limit_response_;
}
inline void CMsgClientLogon::set_supports_rate_limit_response(bool value) {
  set_has_supports_rate_limit_response();
  supports_rate_limit_response_ = value;
}

// optional string web_logon_nonce = 103;
inline bool CMsgClientLogon::has_web_logon_nonce() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void CMsgClientLogon::set_has_web_logon_nonce() {
  _has_bits_[1] |= 0x00020000u;
}
inline void CMsgClientLogon::clear_has_web_logon_nonce() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void CMsgClientLogon::clear_web_logon_nonce() {
  if (web_logon_nonce_ != &::google::protobuf::internal::kEmptyString) {
    web_logon_nonce_->clear();
  }
  clear_has_web_logon_nonce();
}
inline const ::std::string& CMsgClientLogon::web_logon_nonce() const {
  return *web_logon_nonce_;
}
inline void CMsgClientLogon::set_web_logon_nonce(const ::std::string& value) {
  set_has_web_logon_nonce();
  if (web_logon_nonce_ == &::google::protobuf::internal::kEmptyString) {
    web_logon_nonce_ = new ::std::string;
  }
  web_logon_nonce_->assign(value);
}
inline void CMsgClientLogon::set_web_logon_nonce(const char* value) {
  set_has_web_logon_nonce();
  if (web_logon_nonce_ == &::google::protobuf::internal::kEmptyString) {
    web_logon_nonce_ = new ::std::string;
  }
  web_logon_nonce_->assign(value);
}
inline void CMsgClientLogon::set_web_logon_nonce(const char* value, size_t size) {
  set_has_web_logon_nonce();
  if (web_logon_nonce_ == &::google::protobuf::internal::kEmptyString) {
    web_logon_nonce_ = new ::std::string;
  }
  web_logon_nonce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_web_logon_nonce() {
  set_has_web_logon_nonce();
  if (web_logon_nonce_ == &::google::protobuf::internal::kEmptyString) {
    web_logon_nonce_ = new ::std::string;
  }
  return web_logon_nonce_;
}
inline ::std::string* CMsgClientLogon::release_web_logon_nonce() {
  clear_has_web_logon_nonce();
  if (web_logon_nonce_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = web_logon_nonce_;
    web_logon_nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_web_logon_nonce(::std::string* web_logon_nonce) {
  if (web_logon_nonce_ != &::google::protobuf::internal::kEmptyString) {
    delete web_logon_nonce_;
  }
  if (web_logon_nonce) {
    set_has_web_logon_nonce();
    web_logon_nonce_ = web_logon_nonce;
  } else {
    clear_has_web_logon_nonce();
    web_logon_nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 priority_reason = 104;
inline bool CMsgClientLogon::has_priority_reason() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void CMsgClientLogon::set_has_priority_reason() {
  _has_bits_[1] |= 0x00040000u;
}
inline void CMsgClientLogon::clear_has_priority_reason() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void CMsgClientLogon::clear_priority_reason() {
  priority_reason_ = 0;
  clear_has_priority_reason();
}
inline ::google::protobuf::int32 CMsgClientLogon::priority_reason() const {
  return priority_reason_;
}
inline void CMsgClientLogon::set_priority_reason(::google::protobuf::int32 value) {
  set_has_priority_reason();
  priority_reason_ = value;
}

// optional .CMsgClientSecret embedded_client_secret = 105;
inline bool CMsgClientLogon::has_embedded_client_secret() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void CMsgClientLogon::set_has_embedded_client_secret() {
  _has_bits_[1] |= 0x00080000u;
}
inline void CMsgClientLogon::clear_has_embedded_client_secret() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void CMsgClientLogon::clear_embedded_client_secret() {
  if (embedded_client_secret_ != NULL) embedded_client_secret_->::CMsgClientSecret::Clear();
  clear_has_embedded_client_secret();
}
inline const ::CMsgClientSecret& CMsgClientLogon::embedded_client_secret() const {
  return embedded_client_secret_ != NULL ? *embedded_client_secret_ : *default_instance_->embedded_client_secret_;
}
inline ::CMsgClientSecret* CMsgClientLogon::mutable_embedded_client_secret() {
  set_has_embedded_client_secret();
  if (embedded_client_secret_ == NULL) embedded_client_secret_ = new ::CMsgClientSecret;
  return embedded_client_secret_;
}
inline ::CMsgClientSecret* CMsgClientLogon::release_embedded_client_secret() {
  clear_has_embedded_client_secret();
  ::CMsgClientSecret* temp = embedded_client_secret_;
  embedded_client_secret_ = NULL;
  return temp;
}
inline void CMsgClientLogon::set_allocated_embedded_client_secret(::CMsgClientSecret* embedded_client_secret) {
  delete embedded_client_secret_;
  embedded_client_secret_ = embedded_client_secret;
  if (embedded_client_secret) {
    set_has_embedded_client_secret();
  } else {
    clear_has_embedded_client_secret();
  }
}

// optional bool disable_partner_autogrants = 106;
inline bool CMsgClientLogon::has_disable_partner_autogrants() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void CMsgClientLogon::set_has_disable_partner_autogrants() {
  _has_bits_[1] |= 0x00100000u;
}
inline void CMsgClientLogon::clear_has_disable_partner_autogrants() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void CMsgClientLogon::clear_disable_partner_autogrants() {
  disable_partner_autogrants_ = false;
  clear_has_disable_partner_autogrants();
}
inline bool CMsgClientLogon::disable_partner_autogrants() const {
  return disable_partner_autogrants_;
}
inline void CMsgClientLogon::set_disable_partner_autogrants(bool value) {
  set_has_disable_partner_autogrants();
  disable_partner_autogrants_ = value;
}

// optional bool is_steam_deck = 107;
inline bool CMsgClientLogon::has_is_steam_deck() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void CMsgClientLogon::set_has_is_steam_deck() {
  _has_bits_[1] |= 0x00200000u;
}
inline void CMsgClientLogon::clear_has_is_steam_deck() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void CMsgClientLogon::clear_is_steam_deck() {
  is_steam_deck_ = false;
  clear_has_is_steam_deck();
}
inline bool CMsgClientLogon::is_steam_deck() const {
  return is_steam_deck_;
}
inline void CMsgClientLogon::set_is_steam_deck(bool value) {
  set_has_is_steam_deck();
  is_steam_deck_ = value;
}

// optional string access_token = 108;
inline bool CMsgClientLogon::has_access_token() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void CMsgClientLogon::set_has_access_token() {
  _has_bits_[1] |= 0x00400000u;
}
inline void CMsgClientLogon::clear_has_access_token() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void CMsgClientLogon::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::kEmptyString) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& CMsgClientLogon::access_token() const {
  return *access_token_;
}
inline void CMsgClientLogon::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void CMsgClientLogon::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void CMsgClientLogon::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogon::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  return access_token_;
}
inline ::std::string* CMsgClientLogon::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogon::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::kEmptyString) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientLogonResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientLogonResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientLogonResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientLogonResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientLogonResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientLogonResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientLogonResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional int32 legacy_out_of_game_heartbeat_seconds = 2;
inline bool CMsgClientLogonResponse::has_legacy_out_of_game_heartbeat_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientLogonResponse::set_has_legacy_out_of_game_heartbeat_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientLogonResponse::clear_has_legacy_out_of_game_heartbeat_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientLogonResponse::clear_legacy_out_of_game_heartbeat_seconds() {
  legacy_out_of_game_heartbeat_seconds_ = 0;
  clear_has_legacy_out_of_game_heartbeat_seconds();
}
inline ::google::protobuf::int32 CMsgClientLogonResponse::legacy_out_of_game_heartbeat_seconds() const {
  return legacy_out_of_game_heartbeat_seconds_;
}
inline void CMsgClientLogonResponse::set_legacy_out_of_game_heartbeat_seconds(::google::protobuf::int32 value) {
  set_has_legacy_out_of_game_heartbeat_seconds();
  legacy_out_of_game_heartbeat_seconds_ = value;
}

// optional int32 heartbeat_seconds = 3;
inline bool CMsgClientLogonResponse::has_heartbeat_seconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientLogonResponse::set_has_heartbeat_seconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientLogonResponse::clear_has_heartbeat_seconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientLogonResponse::clear_heartbeat_seconds() {
  heartbeat_seconds_ = 0;
  clear_has_heartbeat_seconds();
}
inline ::google::protobuf::int32 CMsgClientLogonResponse::heartbeat_seconds() const {
  return heartbeat_seconds_;
}
inline void CMsgClientLogonResponse::set_heartbeat_seconds(::google::protobuf::int32 value) {
  set_has_heartbeat_seconds();
  heartbeat_seconds_ = value;
}

// optional uint32 deprecated_public_ip = 4;
inline bool CMsgClientLogonResponse::has_deprecated_public_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientLogonResponse::set_has_deprecated_public_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientLogonResponse::clear_has_deprecated_public_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientLogonResponse::clear_deprecated_public_ip() {
  deprecated_public_ip_ = 0u;
  clear_has_deprecated_public_ip();
}
inline ::google::protobuf::uint32 CMsgClientLogonResponse::deprecated_public_ip() const {
  return deprecated_public_ip_;
}
inline void CMsgClientLogonResponse::set_deprecated_public_ip(::google::protobuf::uint32 value) {
  set_has_deprecated_public_ip();
  deprecated_public_ip_ = value;
}

// optional fixed32 rtime32_server_time = 5;
inline bool CMsgClientLogonResponse::has_rtime32_server_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientLogonResponse::set_has_rtime32_server_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientLogonResponse::clear_has_rtime32_server_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientLogonResponse::clear_rtime32_server_time() {
  rtime32_server_time_ = 0u;
  clear_has_rtime32_server_time();
}
inline ::google::protobuf::uint32 CMsgClientLogonResponse::rtime32_server_time() const {
  return rtime32_server_time_;
}
inline void CMsgClientLogonResponse::set_rtime32_server_time(::google::protobuf::uint32 value) {
  set_has_rtime32_server_time();
  rtime32_server_time_ = value;
}

// optional uint32 account_flags = 6;
inline bool CMsgClientLogonResponse::has_account_flags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientLogonResponse::set_has_account_flags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientLogonResponse::clear_has_account_flags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientLogonResponse::clear_account_flags() {
  account_flags_ = 0u;
  clear_has_account_flags();
}
inline ::google::protobuf::uint32 CMsgClientLogonResponse::account_flags() const {
  return account_flags_;
}
inline void CMsgClientLogonResponse::set_account_flags(::google::protobuf::uint32 value) {
  set_has_account_flags();
  account_flags_ = value;
}

// optional uint32 cell_id = 7;
inline bool CMsgClientLogonResponse::has_cell_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientLogonResponse::set_has_cell_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientLogonResponse::clear_has_cell_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientLogonResponse::clear_cell_id() {
  cell_id_ = 0u;
  clear_has_cell_id();
}
inline ::google::protobuf::uint32 CMsgClientLogonResponse::cell_id() const {
  return cell_id_;
}
inline void CMsgClientLogonResponse::set_cell_id(::google::protobuf::uint32 value) {
  set_has_cell_id();
  cell_id_ = value;
}

// optional string email_domain = 8;
inline bool CMsgClientLogonResponse::has_email_domain() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientLogonResponse::set_has_email_domain() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientLogonResponse::clear_has_email_domain() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientLogonResponse::clear_email_domain() {
  if (email_domain_ != &::google::protobuf::internal::kEmptyString) {
    email_domain_->clear();
  }
  clear_has_email_domain();
}
inline const ::std::string& CMsgClientLogonResponse::email_domain() const {
  return *email_domain_;
}
inline void CMsgClientLogonResponse::set_email_domain(const ::std::string& value) {
  set_has_email_domain();
  if (email_domain_ == &::google::protobuf::internal::kEmptyString) {
    email_domain_ = new ::std::string;
  }
  email_domain_->assign(value);
}
inline void CMsgClientLogonResponse::set_email_domain(const char* value) {
  set_has_email_domain();
  if (email_domain_ == &::google::protobuf::internal::kEmptyString) {
    email_domain_ = new ::std::string;
  }
  email_domain_->assign(value);
}
inline void CMsgClientLogonResponse::set_email_domain(const char* value, size_t size) {
  set_has_email_domain();
  if (email_domain_ == &::google::protobuf::internal::kEmptyString) {
    email_domain_ = new ::std::string;
  }
  email_domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogonResponse::mutable_email_domain() {
  set_has_email_domain();
  if (email_domain_ == &::google::protobuf::internal::kEmptyString) {
    email_domain_ = new ::std::string;
  }
  return email_domain_;
}
inline ::std::string* CMsgClientLogonResponse::release_email_domain() {
  clear_has_email_domain();
  if (email_domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_domain_;
    email_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogonResponse::set_allocated_email_domain(::std::string* email_domain) {
  if (email_domain_ != &::google::protobuf::internal::kEmptyString) {
    delete email_domain_;
  }
  if (email_domain) {
    set_has_email_domain();
    email_domain_ = email_domain;
  } else {
    clear_has_email_domain();
    email_domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes steam2_ticket = 9;
inline bool CMsgClientLogonResponse::has_steam2_ticket() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientLogonResponse::set_has_steam2_ticket() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientLogonResponse::clear_has_steam2_ticket() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientLogonResponse::clear_steam2_ticket() {
  if (steam2_ticket_ != &::google::protobuf::internal::kEmptyString) {
    steam2_ticket_->clear();
  }
  clear_has_steam2_ticket();
}
inline const ::std::string& CMsgClientLogonResponse::steam2_ticket() const {
  return *steam2_ticket_;
}
inline void CMsgClientLogonResponse::set_steam2_ticket(const ::std::string& value) {
  set_has_steam2_ticket();
  if (steam2_ticket_ == &::google::protobuf::internal::kEmptyString) {
    steam2_ticket_ = new ::std::string;
  }
  steam2_ticket_->assign(value);
}
inline void CMsgClientLogonResponse::set_steam2_ticket(const char* value) {
  set_has_steam2_ticket();
  if (steam2_ticket_ == &::google::protobuf::internal::kEmptyString) {
    steam2_ticket_ = new ::std::string;
  }
  steam2_ticket_->assign(value);
}
inline void CMsgClientLogonResponse::set_steam2_ticket(const void* value, size_t size) {
  set_has_steam2_ticket();
  if (steam2_ticket_ == &::google::protobuf::internal::kEmptyString) {
    steam2_ticket_ = new ::std::string;
  }
  steam2_ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogonResponse::mutable_steam2_ticket() {
  set_has_steam2_ticket();
  if (steam2_ticket_ == &::google::protobuf::internal::kEmptyString) {
    steam2_ticket_ = new ::std::string;
  }
  return steam2_ticket_;
}
inline ::std::string* CMsgClientLogonResponse::release_steam2_ticket() {
  clear_has_steam2_ticket();
  if (steam2_ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = steam2_ticket_;
    steam2_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogonResponse::set_allocated_steam2_ticket(::std::string* steam2_ticket) {
  if (steam2_ticket_ != &::google::protobuf::internal::kEmptyString) {
    delete steam2_ticket_;
  }
  if (steam2_ticket) {
    set_has_steam2_ticket();
    steam2_ticket_ = steam2_ticket;
  } else {
    clear_has_steam2_ticket();
    steam2_ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 eresult_extended = 10;
inline bool CMsgClientLogonResponse::has_eresult_extended() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientLogonResponse::set_has_eresult_extended() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientLogonResponse::clear_has_eresult_extended() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientLogonResponse::clear_eresult_extended() {
  eresult_extended_ = 0;
  clear_has_eresult_extended();
}
inline ::google::protobuf::int32 CMsgClientLogonResponse::eresult_extended() const {
  return eresult_extended_;
}
inline void CMsgClientLogonResponse::set_eresult_extended(::google::protobuf::int32 value) {
  set_has_eresult_extended();
  eresult_extended_ = value;
}

// optional string webapi_authenticate_user_nonce = 11;
inline bool CMsgClientLogonResponse::has_webapi_authenticate_user_nonce() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgClientLogonResponse::set_has_webapi_authenticate_user_nonce() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgClientLogonResponse::clear_has_webapi_authenticate_user_nonce() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgClientLogonResponse::clear_webapi_authenticate_user_nonce() {
  if (webapi_authenticate_user_nonce_ != &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_->clear();
  }
  clear_has_webapi_authenticate_user_nonce();
}
inline const ::std::string& CMsgClientLogonResponse::webapi_authenticate_user_nonce() const {
  return *webapi_authenticate_user_nonce_;
}
inline void CMsgClientLogonResponse::set_webapi_authenticate_user_nonce(const ::std::string& value) {
  set_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_ = new ::std::string;
  }
  webapi_authenticate_user_nonce_->assign(value);
}
inline void CMsgClientLogonResponse::set_webapi_authenticate_user_nonce(const char* value) {
  set_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_ = new ::std::string;
  }
  webapi_authenticate_user_nonce_->assign(value);
}
inline void CMsgClientLogonResponse::set_webapi_authenticate_user_nonce(const char* value, size_t size) {
  set_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_ = new ::std::string;
  }
  webapi_authenticate_user_nonce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogonResponse::mutable_webapi_authenticate_user_nonce() {
  set_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_ = new ::std::string;
  }
  return webapi_authenticate_user_nonce_;
}
inline ::std::string* CMsgClientLogonResponse::release_webapi_authenticate_user_nonce() {
  clear_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = webapi_authenticate_user_nonce_;
    webapi_authenticate_user_nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogonResponse::set_allocated_webapi_authenticate_user_nonce(::std::string* webapi_authenticate_user_nonce) {
  if (webapi_authenticate_user_nonce_ != &::google::protobuf::internal::kEmptyString) {
    delete webapi_authenticate_user_nonce_;
  }
  if (webapi_authenticate_user_nonce) {
    set_has_webapi_authenticate_user_nonce();
    webapi_authenticate_user_nonce_ = webapi_authenticate_user_nonce;
  } else {
    clear_has_webapi_authenticate_user_nonce();
    webapi_authenticate_user_nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 cell_id_ping_threshold = 12;
inline bool CMsgClientLogonResponse::has_cell_id_ping_threshold() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgClientLogonResponse::set_has_cell_id_ping_threshold() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgClientLogonResponse::clear_has_cell_id_ping_threshold() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgClientLogonResponse::clear_cell_id_ping_threshold() {
  cell_id_ping_threshold_ = 0u;
  clear_has_cell_id_ping_threshold();
}
inline ::google::protobuf::uint32 CMsgClientLogonResponse::cell_id_ping_threshold() const {
  return cell_id_ping_threshold_;
}
inline void CMsgClientLogonResponse::set_cell_id_ping_threshold(::google::protobuf::uint32 value) {
  set_has_cell_id_ping_threshold();
  cell_id_ping_threshold_ = value;
}

// optional bool deprecated_use_pics = 13;
inline bool CMsgClientLogonResponse::has_deprecated_use_pics() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMsgClientLogonResponse::set_has_deprecated_use_pics() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CMsgClientLogonResponse::clear_has_deprecated_use_pics() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CMsgClientLogonResponse::clear_deprecated_use_pics() {
  deprecated_use_pics_ = false;
  clear_has_deprecated_use_pics();
}
inline bool CMsgClientLogonResponse::deprecated_use_pics() const {
  return deprecated_use_pics_;
}
inline void CMsgClientLogonResponse::set_deprecated_use_pics(bool value) {
  set_has_deprecated_use_pics();
  deprecated_use_pics_ = value;
}

// optional string vanity_url = 14;
inline bool CMsgClientLogonResponse::has_vanity_url() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CMsgClientLogonResponse::set_has_vanity_url() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CMsgClientLogonResponse::clear_has_vanity_url() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CMsgClientLogonResponse::clear_vanity_url() {
  if (vanity_url_ != &::google::protobuf::internal::kEmptyString) {
    vanity_url_->clear();
  }
  clear_has_vanity_url();
}
inline const ::std::string& CMsgClientLogonResponse::vanity_url() const {
  return *vanity_url_;
}
inline void CMsgClientLogonResponse::set_vanity_url(const ::std::string& value) {
  set_has_vanity_url();
  if (vanity_url_ == &::google::protobuf::internal::kEmptyString) {
    vanity_url_ = new ::std::string;
  }
  vanity_url_->assign(value);
}
inline void CMsgClientLogonResponse::set_vanity_url(const char* value) {
  set_has_vanity_url();
  if (vanity_url_ == &::google::protobuf::internal::kEmptyString) {
    vanity_url_ = new ::std::string;
  }
  vanity_url_->assign(value);
}
inline void CMsgClientLogonResponse::set_vanity_url(const char* value, size_t size) {
  set_has_vanity_url();
  if (vanity_url_ == &::google::protobuf::internal::kEmptyString) {
    vanity_url_ = new ::std::string;
  }
  vanity_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogonResponse::mutable_vanity_url() {
  set_has_vanity_url();
  if (vanity_url_ == &::google::protobuf::internal::kEmptyString) {
    vanity_url_ = new ::std::string;
  }
  return vanity_url_;
}
inline ::std::string* CMsgClientLogonResponse::release_vanity_url() {
  clear_has_vanity_url();
  if (vanity_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vanity_url_;
    vanity_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogonResponse::set_allocated_vanity_url(::std::string* vanity_url) {
  if (vanity_url_ != &::google::protobuf::internal::kEmptyString) {
    delete vanity_url_;
  }
  if (vanity_url) {
    set_has_vanity_url();
    vanity_url_ = vanity_url;
  } else {
    clear_has_vanity_url();
    vanity_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .CMsgIPAddress public_ip = 15;
inline bool CMsgClientLogonResponse::has_public_ip() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CMsgClientLogonResponse::set_has_public_ip() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CMsgClientLogonResponse::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CMsgClientLogonResponse::clear_public_ip() {
  if (public_ip_ != NULL) public_ip_->::CMsgIPAddress::Clear();
  clear_has_public_ip();
}
inline const ::CMsgIPAddress& CMsgClientLogonResponse::public_ip() const {
  return public_ip_ != NULL ? *public_ip_ : *default_instance_->public_ip_;
}
inline ::CMsgIPAddress* CMsgClientLogonResponse::mutable_public_ip() {
  set_has_public_ip();
  if (public_ip_ == NULL) public_ip_ = new ::CMsgIPAddress;
  return public_ip_;
}
inline ::CMsgIPAddress* CMsgClientLogonResponse::release_public_ip() {
  clear_has_public_ip();
  ::CMsgIPAddress* temp = public_ip_;
  public_ip_ = NULL;
  return temp;
}
inline void CMsgClientLogonResponse::set_allocated_public_ip(::CMsgIPAddress* public_ip) {
  delete public_ip_;
  public_ip_ = public_ip;
  if (public_ip) {
    set_has_public_ip();
  } else {
    clear_has_public_ip();
  }
}

// optional fixed64 client_supplied_steamid = 20;
inline bool CMsgClientLogonResponse::has_client_supplied_steamid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CMsgClientLogonResponse::set_has_client_supplied_steamid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CMsgClientLogonResponse::clear_has_client_supplied_steamid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CMsgClientLogonResponse::clear_client_supplied_steamid() {
  client_supplied_steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_client_supplied_steamid();
}
inline ::google::protobuf::uint64 CMsgClientLogonResponse::client_supplied_steamid() const {
  return client_supplied_steamid_;
}
inline void CMsgClientLogonResponse::set_client_supplied_steamid(::google::protobuf::uint64 value) {
  set_has_client_supplied_steamid();
  client_supplied_steamid_ = value;
}

// optional string ip_country_code = 21;
inline bool CMsgClientLogonResponse::has_ip_country_code() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CMsgClientLogonResponse::set_has_ip_country_code() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CMsgClientLogonResponse::clear_has_ip_country_code() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CMsgClientLogonResponse::clear_ip_country_code() {
  if (ip_country_code_ != &::google::protobuf::internal::kEmptyString) {
    ip_country_code_->clear();
  }
  clear_has_ip_country_code();
}
inline const ::std::string& CMsgClientLogonResponse::ip_country_code() const {
  return *ip_country_code_;
}
inline void CMsgClientLogonResponse::set_ip_country_code(const ::std::string& value) {
  set_has_ip_country_code();
  if (ip_country_code_ == &::google::protobuf::internal::kEmptyString) {
    ip_country_code_ = new ::std::string;
  }
  ip_country_code_->assign(value);
}
inline void CMsgClientLogonResponse::set_ip_country_code(const char* value) {
  set_has_ip_country_code();
  if (ip_country_code_ == &::google::protobuf::internal::kEmptyString) {
    ip_country_code_ = new ::std::string;
  }
  ip_country_code_->assign(value);
}
inline void CMsgClientLogonResponse::set_ip_country_code(const char* value, size_t size) {
  set_has_ip_country_code();
  if (ip_country_code_ == &::google::protobuf::internal::kEmptyString) {
    ip_country_code_ = new ::std::string;
  }
  ip_country_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogonResponse::mutable_ip_country_code() {
  set_has_ip_country_code();
  if (ip_country_code_ == &::google::protobuf::internal::kEmptyString) {
    ip_country_code_ = new ::std::string;
  }
  return ip_country_code_;
}
inline ::std::string* CMsgClientLogonResponse::release_ip_country_code() {
  clear_has_ip_country_code();
  if (ip_country_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_country_code_;
    ip_country_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogonResponse::set_allocated_ip_country_code(::std::string* ip_country_code) {
  if (ip_country_code_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_country_code_;
  }
  if (ip_country_code) {
    set_has_ip_country_code();
    ip_country_code_ = ip_country_code;
  } else {
    clear_has_ip_country_code();
    ip_country_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes parental_settings = 22;
inline bool CMsgClientLogonResponse::has_parental_settings() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CMsgClientLogonResponse::set_has_parental_settings() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CMsgClientLogonResponse::clear_has_parental_settings() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CMsgClientLogonResponse::clear_parental_settings() {
  if (parental_settings_ != &::google::protobuf::internal::kEmptyString) {
    parental_settings_->clear();
  }
  clear_has_parental_settings();
}
inline const ::std::string& CMsgClientLogonResponse::parental_settings() const {
  return *parental_settings_;
}
inline void CMsgClientLogonResponse::set_parental_settings(const ::std::string& value) {
  set_has_parental_settings();
  if (parental_settings_ == &::google::protobuf::internal::kEmptyString) {
    parental_settings_ = new ::std::string;
  }
  parental_settings_->assign(value);
}
inline void CMsgClientLogonResponse::set_parental_settings(const char* value) {
  set_has_parental_settings();
  if (parental_settings_ == &::google::protobuf::internal::kEmptyString) {
    parental_settings_ = new ::std::string;
  }
  parental_settings_->assign(value);
}
inline void CMsgClientLogonResponse::set_parental_settings(const void* value, size_t size) {
  set_has_parental_settings();
  if (parental_settings_ == &::google::protobuf::internal::kEmptyString) {
    parental_settings_ = new ::std::string;
  }
  parental_settings_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogonResponse::mutable_parental_settings() {
  set_has_parental_settings();
  if (parental_settings_ == &::google::protobuf::internal::kEmptyString) {
    parental_settings_ = new ::std::string;
  }
  return parental_settings_;
}
inline ::std::string* CMsgClientLogonResponse::release_parental_settings() {
  clear_has_parental_settings();
  if (parental_settings_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parental_settings_;
    parental_settings_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogonResponse::set_allocated_parental_settings(::std::string* parental_settings) {
  if (parental_settings_ != &::google::protobuf::internal::kEmptyString) {
    delete parental_settings_;
  }
  if (parental_settings) {
    set_has_parental_settings();
    parental_settings_ = parental_settings;
  } else {
    clear_has_parental_settings();
    parental_settings_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes parental_setting_signature = 23;
inline bool CMsgClientLogonResponse::has_parental_setting_signature() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CMsgClientLogonResponse::set_has_parental_setting_signature() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CMsgClientLogonResponse::clear_has_parental_setting_signature() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CMsgClientLogonResponse::clear_parental_setting_signature() {
  if (parental_setting_signature_ != &::google::protobuf::internal::kEmptyString) {
    parental_setting_signature_->clear();
  }
  clear_has_parental_setting_signature();
}
inline const ::std::string& CMsgClientLogonResponse::parental_setting_signature() const {
  return *parental_setting_signature_;
}
inline void CMsgClientLogonResponse::set_parental_setting_signature(const ::std::string& value) {
  set_has_parental_setting_signature();
  if (parental_setting_signature_ == &::google::protobuf::internal::kEmptyString) {
    parental_setting_signature_ = new ::std::string;
  }
  parental_setting_signature_->assign(value);
}
inline void CMsgClientLogonResponse::set_parental_setting_signature(const char* value) {
  set_has_parental_setting_signature();
  if (parental_setting_signature_ == &::google::protobuf::internal::kEmptyString) {
    parental_setting_signature_ = new ::std::string;
  }
  parental_setting_signature_->assign(value);
}
inline void CMsgClientLogonResponse::set_parental_setting_signature(const void* value, size_t size) {
  set_has_parental_setting_signature();
  if (parental_setting_signature_ == &::google::protobuf::internal::kEmptyString) {
    parental_setting_signature_ = new ::std::string;
  }
  parental_setting_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogonResponse::mutable_parental_setting_signature() {
  set_has_parental_setting_signature();
  if (parental_setting_signature_ == &::google::protobuf::internal::kEmptyString) {
    parental_setting_signature_ = new ::std::string;
  }
  return parental_setting_signature_;
}
inline ::std::string* CMsgClientLogonResponse::release_parental_setting_signature() {
  clear_has_parental_setting_signature();
  if (parental_setting_signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parental_setting_signature_;
    parental_setting_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogonResponse::set_allocated_parental_setting_signature(::std::string* parental_setting_signature) {
  if (parental_setting_signature_ != &::google::protobuf::internal::kEmptyString) {
    delete parental_setting_signature_;
  }
  if (parental_setting_signature) {
    set_has_parental_setting_signature();
    parental_setting_signature_ = parental_setting_signature;
  } else {
    clear_has_parental_setting_signature();
    parental_setting_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 count_loginfailures_to_migrate = 24;
inline bool CMsgClientLogonResponse::has_count_loginfailures_to_migrate() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CMsgClientLogonResponse::set_has_count_loginfailures_to_migrate() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CMsgClientLogonResponse::clear_has_count_loginfailures_to_migrate() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CMsgClientLogonResponse::clear_count_loginfailures_to_migrate() {
  count_loginfailures_to_migrate_ = 0;
  clear_has_count_loginfailures_to_migrate();
}
inline ::google::protobuf::int32 CMsgClientLogonResponse::count_loginfailures_to_migrate() const {
  return count_loginfailures_to_migrate_;
}
inline void CMsgClientLogonResponse::set_count_loginfailures_to_migrate(::google::protobuf::int32 value) {
  set_has_count_loginfailures_to_migrate();
  count_loginfailures_to_migrate_ = value;
}

// optional int32 count_disconnects_to_migrate = 25;
inline bool CMsgClientLogonResponse::has_count_disconnects_to_migrate() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CMsgClientLogonResponse::set_has_count_disconnects_to_migrate() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CMsgClientLogonResponse::clear_has_count_disconnects_to_migrate() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CMsgClientLogonResponse::clear_count_disconnects_to_migrate() {
  count_disconnects_to_migrate_ = 0;
  clear_has_count_disconnects_to_migrate();
}
inline ::google::protobuf::int32 CMsgClientLogonResponse::count_disconnects_to_migrate() const {
  return count_disconnects_to_migrate_;
}
inline void CMsgClientLogonResponse::set_count_disconnects_to_migrate(::google::protobuf::int32 value) {
  set_has_count_disconnects_to_migrate();
  count_disconnects_to_migrate_ = value;
}

// optional int32 ogs_data_report_time_window = 26;
inline bool CMsgClientLogonResponse::has_ogs_data_report_time_window() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CMsgClientLogonResponse::set_has_ogs_data_report_time_window() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CMsgClientLogonResponse::clear_has_ogs_data_report_time_window() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CMsgClientLogonResponse::clear_ogs_data_report_time_window() {
  ogs_data_report_time_window_ = 0;
  clear_has_ogs_data_report_time_window();
}
inline ::google::protobuf::int32 CMsgClientLogonResponse::ogs_data_report_time_window() const {
  return ogs_data_report_time_window_;
}
inline void CMsgClientLogonResponse::set_ogs_data_report_time_window(::google::protobuf::int32 value) {
  set_has_ogs_data_report_time_window();
  ogs_data_report_time_window_ = value;
}

// optional uint64 client_instance_id = 27;
inline bool CMsgClientLogonResponse::has_client_instance_id() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CMsgClientLogonResponse::set_has_client_instance_id() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CMsgClientLogonResponse::clear_has_client_instance_id() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CMsgClientLogonResponse::clear_client_instance_id() {
  client_instance_id_ = GOOGLE_ULONGLONG(0);
  clear_has_client_instance_id();
}
inline ::google::protobuf::uint64 CMsgClientLogonResponse::client_instance_id() const {
  return client_instance_id_;
}
inline void CMsgClientLogonResponse::set_client_instance_id(::google::protobuf::uint64 value) {
  set_has_client_instance_id();
  client_instance_id_ = value;
}

// optional bool force_client_update_check = 28;
inline bool CMsgClientLogonResponse::has_force_client_update_check() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CMsgClientLogonResponse::set_has_force_client_update_check() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CMsgClientLogonResponse::clear_has_force_client_update_check() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CMsgClientLogonResponse::clear_force_client_update_check() {
  force_client_update_check_ = false;
  clear_has_force_client_update_check();
}
inline bool CMsgClientLogonResponse::force_client_update_check() const {
  return force_client_update_check_;
}
inline void CMsgClientLogonResponse::set_force_client_update_check(bool value) {
  set_has_force_client_update_check();
  force_client_update_check_ = value;
}

// optional string agreement_session_url = 29;
inline bool CMsgClientLogonResponse::has_agreement_session_url() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CMsgClientLogonResponse::set_has_agreement_session_url() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CMsgClientLogonResponse::clear_has_agreement_session_url() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CMsgClientLogonResponse::clear_agreement_session_url() {
  if (agreement_session_url_ != &::google::protobuf::internal::kEmptyString) {
    agreement_session_url_->clear();
  }
  clear_has_agreement_session_url();
}
inline const ::std::string& CMsgClientLogonResponse::agreement_session_url() const {
  return *agreement_session_url_;
}
inline void CMsgClientLogonResponse::set_agreement_session_url(const ::std::string& value) {
  set_has_agreement_session_url();
  if (agreement_session_url_ == &::google::protobuf::internal::kEmptyString) {
    agreement_session_url_ = new ::std::string;
  }
  agreement_session_url_->assign(value);
}
inline void CMsgClientLogonResponse::set_agreement_session_url(const char* value) {
  set_has_agreement_session_url();
  if (agreement_session_url_ == &::google::protobuf::internal::kEmptyString) {
    agreement_session_url_ = new ::std::string;
  }
  agreement_session_url_->assign(value);
}
inline void CMsgClientLogonResponse::set_agreement_session_url(const char* value, size_t size) {
  set_has_agreement_session_url();
  if (agreement_session_url_ == &::google::protobuf::internal::kEmptyString) {
    agreement_session_url_ = new ::std::string;
  }
  agreement_session_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientLogonResponse::mutable_agreement_session_url() {
  set_has_agreement_session_url();
  if (agreement_session_url_ == &::google::protobuf::internal::kEmptyString) {
    agreement_session_url_ = new ::std::string;
  }
  return agreement_session_url_;
}
inline ::std::string* CMsgClientLogonResponse::release_agreement_session_url() {
  clear_has_agreement_session_url();
  if (agreement_session_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agreement_session_url_;
    agreement_session_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientLogonResponse::set_allocated_agreement_session_url(::std::string* agreement_session_url) {
  if (agreement_session_url_ != &::google::protobuf::internal::kEmptyString) {
    delete agreement_session_url_;
  }
  if (agreement_session_url) {
    set_has_agreement_session_url();
    agreement_session_url_ = agreement_session_url;
  } else {
    clear_has_agreement_session_url();
    agreement_session_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 token_id = 30;
inline bool CMsgClientLogonResponse::has_token_id() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CMsgClientLogonResponse::set_has_token_id() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CMsgClientLogonResponse::clear_has_token_id() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CMsgClientLogonResponse::clear_token_id() {
  token_id_ = GOOGLE_ULONGLONG(0);
  clear_has_token_id();
}
inline ::google::protobuf::uint64 CMsgClientLogonResponse::token_id() const {
  return token_id_;
}
inline void CMsgClientLogonResponse::set_token_id(::google::protobuf::uint64 value) {
  set_has_token_id();
  token_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientRequestWebAPIAuthenticateUserNonce

// optional int32 token_type = 1 [default = -1];
inline bool CMsgClientRequestWebAPIAuthenticateUserNonce::has_token_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonce::set_has_token_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonce::clear_has_token_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonce::clear_token_type() {
  token_type_ = -1;
  clear_has_token_type();
}
inline ::google::protobuf::int32 CMsgClientRequestWebAPIAuthenticateUserNonce::token_type() const {
  return token_type_;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonce::set_token_type(::google::protobuf::int32 value) {
  set_has_token_type();
  token_type_ = value;
}

// -------------------------------------------------------------------

// CMsgClientRequestWebAPIAuthenticateUserNonceResponse

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientRequestWebAPIAuthenticateUserNonceResponse::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientRequestWebAPIAuthenticateUserNonceResponse::eresult() const {
  return eresult_;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// optional string webapi_authenticate_user_nonce = 11;
inline bool CMsgClientRequestWebAPIAuthenticateUserNonceResponse::has_webapi_authenticate_user_nonce() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_has_webapi_authenticate_user_nonce() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::clear_has_webapi_authenticate_user_nonce() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::clear_webapi_authenticate_user_nonce() {
  if (webapi_authenticate_user_nonce_ != &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_->clear();
  }
  clear_has_webapi_authenticate_user_nonce();
}
inline const ::std::string& CMsgClientRequestWebAPIAuthenticateUserNonceResponse::webapi_authenticate_user_nonce() const {
  return *webapi_authenticate_user_nonce_;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_webapi_authenticate_user_nonce(const ::std::string& value) {
  set_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_ = new ::std::string;
  }
  webapi_authenticate_user_nonce_->assign(value);
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_webapi_authenticate_user_nonce(const char* value) {
  set_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_ = new ::std::string;
  }
  webapi_authenticate_user_nonce_->assign(value);
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_webapi_authenticate_user_nonce(const char* value, size_t size) {
  set_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_ = new ::std::string;
  }
  webapi_authenticate_user_nonce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientRequestWebAPIAuthenticateUserNonceResponse::mutable_webapi_authenticate_user_nonce() {
  set_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    webapi_authenticate_user_nonce_ = new ::std::string;
  }
  return webapi_authenticate_user_nonce_;
}
inline ::std::string* CMsgClientRequestWebAPIAuthenticateUserNonceResponse::release_webapi_authenticate_user_nonce() {
  clear_has_webapi_authenticate_user_nonce();
  if (webapi_authenticate_user_nonce_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = webapi_authenticate_user_nonce_;
    webapi_authenticate_user_nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_allocated_webapi_authenticate_user_nonce(::std::string* webapi_authenticate_user_nonce) {
  if (webapi_authenticate_user_nonce_ != &::google::protobuf::internal::kEmptyString) {
    delete webapi_authenticate_user_nonce_;
  }
  if (webapi_authenticate_user_nonce) {
    set_has_webapi_authenticate_user_nonce();
    webapi_authenticate_user_nonce_ = webapi_authenticate_user_nonce;
  } else {
    clear_has_webapi_authenticate_user_nonce();
    webapi_authenticate_user_nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 token_type = 3 [default = -1];
inline bool CMsgClientRequestWebAPIAuthenticateUserNonceResponse::has_token_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_has_token_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::clear_has_token_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::clear_token_type() {
  token_type_ = -1;
  clear_has_token_type();
}
inline ::google::protobuf::int32 CMsgClientRequestWebAPIAuthenticateUserNonceResponse::token_type() const {
  return token_type_;
}
inline void CMsgClientRequestWebAPIAuthenticateUserNonceResponse::set_token_type(::google::protobuf::int32 value) {
  set_has_token_type();
  token_type_ = value;
}

// -------------------------------------------------------------------

// CMsgClientLogOff

// -------------------------------------------------------------------

// CMsgClientLoggedOff

// optional int32 eresult = 1 [default = 2];
inline bool CMsgClientLoggedOff::has_eresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientLoggedOff::set_has_eresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientLoggedOff::clear_has_eresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientLoggedOff::clear_eresult() {
  eresult_ = 2;
  clear_has_eresult();
}
inline ::google::protobuf::int32 CMsgClientLoggedOff::eresult() const {
  return eresult_;
}
inline void CMsgClientLoggedOff::set_eresult(::google::protobuf::int32 value) {
  set_has_eresult();
  eresult_ = value;
}

// -------------------------------------------------------------------

// CMsgClientNewLoginKey

// optional uint32 unique_id = 1;
inline bool CMsgClientNewLoginKey::has_unique_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientNewLoginKey::set_has_unique_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientNewLoginKey::clear_has_unique_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientNewLoginKey::clear_unique_id() {
  unique_id_ = 0u;
  clear_has_unique_id();
}
inline ::google::protobuf::uint32 CMsgClientNewLoginKey::unique_id() const {
  return unique_id_;
}
inline void CMsgClientNewLoginKey::set_unique_id(::google::protobuf::uint32 value) {
  set_has_unique_id();
  unique_id_ = value;
}

// optional string login_key = 2;
inline bool CMsgClientNewLoginKey::has_login_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientNewLoginKey::set_has_login_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientNewLoginKey::clear_has_login_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientNewLoginKey::clear_login_key() {
  if (login_key_ != &::google::protobuf::internal::kEmptyString) {
    login_key_->clear();
  }
  clear_has_login_key();
}
inline const ::std::string& CMsgClientNewLoginKey::login_key() const {
  return *login_key_;
}
inline void CMsgClientNewLoginKey::set_login_key(const ::std::string& value) {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  login_key_->assign(value);
}
inline void CMsgClientNewLoginKey::set_login_key(const char* value) {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  login_key_->assign(value);
}
inline void CMsgClientNewLoginKey::set_login_key(const char* value, size_t size) {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  login_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientNewLoginKey::mutable_login_key() {
  set_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    login_key_ = new ::std::string;
  }
  return login_key_;
}
inline ::std::string* CMsgClientNewLoginKey::release_login_key() {
  clear_has_login_key();
  if (login_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = login_key_;
    login_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientNewLoginKey::set_allocated_login_key(::std::string* login_key) {
  if (login_key_ != &::google::protobuf::internal::kEmptyString) {
    delete login_key_;
  }
  if (login_key) {
    set_has_login_key();
    login_key_ = login_key;
  } else {
    clear_has_login_key();
    login_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CMsgClientNewLoginKeyAccepted

// optional uint32 unique_id = 1;
inline bool CMsgClientNewLoginKeyAccepted::has_unique_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientNewLoginKeyAccepted::set_has_unique_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientNewLoginKeyAccepted::clear_has_unique_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientNewLoginKeyAccepted::clear_unique_id() {
  unique_id_ = 0u;
  clear_has_unique_id();
}
inline ::google::protobuf::uint32 CMsgClientNewLoginKeyAccepted::unique_id() const {
  return unique_id_;
}
inline void CMsgClientNewLoginKeyAccepted::set_unique_id(::google::protobuf::uint32 value) {
  set_has_unique_id();
  unique_id_ = value;
}

// -------------------------------------------------------------------

// CMsgClientAccountInfo

// optional string persona_name = 1;
inline bool CMsgClientAccountInfo::has_persona_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientAccountInfo::set_has_persona_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientAccountInfo::clear_has_persona_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientAccountInfo::clear_persona_name() {
  if (persona_name_ != &::google::protobuf::internal::kEmptyString) {
    persona_name_->clear();
  }
  clear_has_persona_name();
}
inline const ::std::string& CMsgClientAccountInfo::persona_name() const {
  return *persona_name_;
}
inline void CMsgClientAccountInfo::set_persona_name(const ::std::string& value) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(value);
}
inline void CMsgClientAccountInfo::set_persona_name(const char* value) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(value);
}
inline void CMsgClientAccountInfo::set_persona_name(const char* value, size_t size) {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  persona_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientAccountInfo::mutable_persona_name() {
  set_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    persona_name_ = new ::std::string;
  }
  return persona_name_;
}
inline ::std::string* CMsgClientAccountInfo::release_persona_name() {
  clear_has_persona_name();
  if (persona_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = persona_name_;
    persona_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientAccountInfo::set_allocated_persona_name(::std::string* persona_name) {
  if (persona_name_ != &::google::protobuf::internal::kEmptyString) {
    delete persona_name_;
  }
  if (persona_name) {
    set_has_persona_name();
    persona_name_ = persona_name;
  } else {
    clear_has_persona_name();
    persona_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip_country = 2;
inline bool CMsgClientAccountInfo::has_ip_country() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMsgClientAccountInfo::set_has_ip_country() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMsgClientAccountInfo::clear_has_ip_country() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMsgClientAccountInfo::clear_ip_country() {
  if (ip_country_ != &::google::protobuf::internal::kEmptyString) {
    ip_country_->clear();
  }
  clear_has_ip_country();
}
inline const ::std::string& CMsgClientAccountInfo::ip_country() const {
  return *ip_country_;
}
inline void CMsgClientAccountInfo::set_ip_country(const ::std::string& value) {
  set_has_ip_country();
  if (ip_country_ == &::google::protobuf::internal::kEmptyString) {
    ip_country_ = new ::std::string;
  }
  ip_country_->assign(value);
}
inline void CMsgClientAccountInfo::set_ip_country(const char* value) {
  set_has_ip_country();
  if (ip_country_ == &::google::protobuf::internal::kEmptyString) {
    ip_country_ = new ::std::string;
  }
  ip_country_->assign(value);
}
inline void CMsgClientAccountInfo::set_ip_country(const char* value, size_t size) {
  set_has_ip_country();
  if (ip_country_ == &::google::protobuf::internal::kEmptyString) {
    ip_country_ = new ::std::string;
  }
  ip_country_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientAccountInfo::mutable_ip_country() {
  set_has_ip_country();
  if (ip_country_ == &::google::protobuf::internal::kEmptyString) {
    ip_country_ = new ::std::string;
  }
  return ip_country_;
}
inline ::std::string* CMsgClientAccountInfo::release_ip_country() {
  clear_has_ip_country();
  if (ip_country_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_country_;
    ip_country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientAccountInfo::set_allocated_ip_country(::std::string* ip_country) {
  if (ip_country_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_country_;
  }
  if (ip_country) {
    set_has_ip_country();
    ip_country_ = ip_country;
  } else {
    clear_has_ip_country();
    ip_country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 count_authed_computers = 5;
inline bool CMsgClientAccountInfo::has_count_authed_computers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMsgClientAccountInfo::set_has_count_authed_computers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMsgClientAccountInfo::clear_has_count_authed_computers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMsgClientAccountInfo::clear_count_authed_computers() {
  count_authed_computers_ = 0;
  clear_has_count_authed_computers();
}
inline ::google::protobuf::int32 CMsgClientAccountInfo::count_authed_computers() const {
  return count_authed_computers_;
}
inline void CMsgClientAccountInfo::set_count_authed_computers(::google::protobuf::int32 value) {
  set_has_count_authed_computers();
  count_authed_computers_ = value;
}

// optional uint32 account_flags = 7;
inline bool CMsgClientAccountInfo::has_account_flags() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMsgClientAccountInfo::set_has_account_flags() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMsgClientAccountInfo::clear_has_account_flags() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMsgClientAccountInfo::clear_account_flags() {
  account_flags_ = 0u;
  clear_has_account_flags();
}
inline ::google::protobuf::uint32 CMsgClientAccountInfo::account_flags() const {
  return account_flags_;
}
inline void CMsgClientAccountInfo::set_account_flags(::google::protobuf::uint32 value) {
  set_has_account_flags();
  account_flags_ = value;
}

// optional uint64 facebook_id = 8;
inline bool CMsgClientAccountInfo::has_facebook_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMsgClientAccountInfo::set_has_facebook_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMsgClientAccountInfo::clear_has_facebook_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMsgClientAccountInfo::clear_facebook_id() {
  facebook_id_ = GOOGLE_ULONGLONG(0);
  clear_has_facebook_id();
}
inline ::google::protobuf::uint64 CMsgClientAccountInfo::facebook_id() const {
  return facebook_id_;
}
inline void CMsgClientAccountInfo::set_facebook_id(::google::protobuf::uint64 value) {
  set_has_facebook_id();
  facebook_id_ = value;
}

// optional string facebook_name = 9;
inline bool CMsgClientAccountInfo::has_facebook_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMsgClientAccountInfo::set_has_facebook_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMsgClientAccountInfo::clear_has_facebook_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMsgClientAccountInfo::clear_facebook_name() {
  if (facebook_name_ != &::google::protobuf::internal::kEmptyString) {
    facebook_name_->clear();
  }
  clear_has_facebook_name();
}
inline const ::std::string& CMsgClientAccountInfo::facebook_name() const {
  return *facebook_name_;
}
inline void CMsgClientAccountInfo::set_facebook_name(const ::std::string& value) {
  set_has_facebook_name();
  if (facebook_name_ == &::google::protobuf::internal::kEmptyString) {
    facebook_name_ = new ::std::string;
  }
  facebook_name_->assign(value);
}
inline void CMsgClientAccountInfo::set_facebook_name(const char* value) {
  set_has_facebook_name();
  if (facebook_name_ == &::google::protobuf::internal::kEmptyString) {
    facebook_name_ = new ::std::string;
  }
  facebook_name_->assign(value);
}
inline void CMsgClientAccountInfo::set_facebook_name(const char* value, size_t size) {
  set_has_facebook_name();
  if (facebook_name_ == &::google::protobuf::internal::kEmptyString) {
    facebook_name_ = new ::std::string;
  }
  facebook_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientAccountInfo::mutable_facebook_name() {
  set_has_facebook_name();
  if (facebook_name_ == &::google::protobuf::internal::kEmptyString) {
    facebook_name_ = new ::std::string;
  }
  return facebook_name_;
}
inline ::std::string* CMsgClientAccountInfo::release_facebook_name() {
  clear_has_facebook_name();
  if (facebook_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = facebook_name_;
    facebook_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientAccountInfo::set_allocated_facebook_name(::std::string* facebook_name) {
  if (facebook_name_ != &::google::protobuf::internal::kEmptyString) {
    delete facebook_name_;
  }
  if (facebook_name) {
    set_has_facebook_name();
    facebook_name_ = facebook_name;
  } else {
    clear_has_facebook_name();
    facebook_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool steamguard_notify_newmachines = 14;
inline bool CMsgClientAccountInfo::has_steamguard_notify_newmachines() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMsgClientAccountInfo::set_has_steamguard_notify_newmachines() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMsgClientAccountInfo::clear_has_steamguard_notify_newmachines() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMsgClientAccountInfo::clear_steamguard_notify_newmachines() {
  steamguard_notify_newmachines_ = false;
  clear_has_steamguard_notify_newmachines();
}
inline bool CMsgClientAccountInfo::steamguard_notify_newmachines() const {
  return steamguard_notify_newmachines_;
}
inline void CMsgClientAccountInfo::set_steamguard_notify_newmachines(bool value) {
  set_has_steamguard_notify_newmachines();
  steamguard_notify_newmachines_ = value;
}

// optional string steamguard_machine_name_user_chosen = 15;
inline bool CMsgClientAccountInfo::has_steamguard_machine_name_user_chosen() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMsgClientAccountInfo::set_has_steamguard_machine_name_user_chosen() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMsgClientAccountInfo::clear_has_steamguard_machine_name_user_chosen() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMsgClientAccountInfo::clear_steamguard_machine_name_user_chosen() {
  if (steamguard_machine_name_user_chosen_ != &::google::protobuf::internal::kEmptyString) {
    steamguard_machine_name_user_chosen_->clear();
  }
  clear_has_steamguard_machine_name_user_chosen();
}
inline const ::std::string& CMsgClientAccountInfo::steamguard_machine_name_user_chosen() const {
  return *steamguard_machine_name_user_chosen_;
}
inline void CMsgClientAccountInfo::set_steamguard_machine_name_user_chosen(const ::std::string& value) {
  set_has_steamguard_machine_name_user_chosen();
  if (steamguard_machine_name_user_chosen_ == &::google::protobuf::internal::kEmptyString) {
    steamguard_machine_name_user_chosen_ = new ::std::string;
  }
  steamguard_machine_name_user_chosen_->assign(value);
}
inline void CMsgClientAccountInfo::set_steamguard_machine_name_user_chosen(const char* value) {
  set_has_steamguard_machine_name_user_chosen();
  if (steamguard_machine_name_user_chosen_ == &::google::protobuf::internal::kEmptyString) {
    steamguard_machine_name_user_chosen_ = new ::std::string;
  }
  steamguard_machine_name_user_chosen_->assign(value);
}
inline void CMsgClientAccountInfo::set_steamguard_machine_name_user_chosen(const char* value, size_t size) {
  set_has_steamguard_machine_name_user_chosen();
  if (steamguard_machine_name_user_chosen_ == &::google::protobuf::internal::kEmptyString) {
    steamguard_machine_name_user_chosen_ = new ::std::string;
  }
  steamguard_machine_name_user_chosen_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMsgClientAccountInfo::mutable_steamguard_machine_name_user_chosen() {
  set_has_steamguard_machine_name_user_chosen();
  if (steamguard_machine_name_user_chosen_ == &::google::protobuf::internal::kEmptyString) {
    steamguard_machine_name_user_chosen_ = new ::std::string;
  }
  return steamguard_machine_name_user_chosen_;
}
inline ::std::string* CMsgClientAccountInfo::release_steamguard_machine_name_user_chosen() {
  clear_has_steamguard_machine_name_user_chosen();
  if (steamguard_machine_name_user_chosen_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = steamguard_machine_name_user_chosen_;
    steamguard_machine_name_user_chosen_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CMsgClientAccountInfo::set_allocated_steamguard_machine_name_user_chosen(::std::string* steamguard_machine_name_user_chosen) {
  if (steamguard_machine_name_user_chosen_ != &::google::protobuf::internal::kEmptyString) {
    delete steamguard_machine_name_user_chosen_;
  }
  if (steamguard_machine_name_user_chosen) {
    set_has_steamguard_machine_name_user_chosen();
    steamguard_machine_name_user_chosen_ = steamguard_machine_name_user_chosen;
  } else {
    clear_has_steamguard_machine_name_user_chosen();
    steamguard_machine_name_user_chosen_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_phone_verified = 16;
inline bool CMsgClientAccountInfo::has_is_phone_verified() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgClientAccountInfo::set_has_is_phone_verified() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgClientAccountInfo::clear_has_is_phone_verified() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgClientAccountInfo::clear_is_phone_verified() {
  is_phone_verified_ = false;
  clear_has_is_phone_verified();
}
inline bool CMsgClientAccountInfo::is_phone_verified() const {
  return is_phone_verified_;
}
inline void CMsgClientAccountInfo::set_is_phone_verified(bool value) {
  set_has_is_phone_verified();
  is_phone_verified_ = value;
}

// optional uint32 two_factor_state = 17;
inline bool CMsgClientAccountInfo::has_two_factor_state() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgClientAccountInfo::set_has_two_factor_state() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgClientAccountInfo::clear_has_two_factor_state() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgClientAccountInfo::clear_two_factor_state() {
  two_factor_state_ = 0u;
  clear_has_two_factor_state();
}
inline ::google::protobuf::uint32 CMsgClientAccountInfo::two_factor_state() const {
  return two_factor_state_;
}
inline void CMsgClientAccountInfo::set_two_factor_state(::google::protobuf::uint32 value) {
  set_has_two_factor_state();
  two_factor_state_ = value;
}

// optional bool is_phone_identifying = 18;
inline bool CMsgClientAccountInfo::has_is_phone_identifying() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMsgClientAccountInfo::set_has_is_phone_identifying() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMsgClientAccountInfo::clear_has_is_phone_identifying() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMsgClientAccountInfo::clear_is_phone_identifying() {
  is_phone_identifying_ = false;
  clear_has_is_phone_identifying();
}
inline bool CMsgClientAccountInfo::is_phone_identifying() const {
  return is_phone_identifying_;
}
inline void CMsgClientAccountInfo::set_is_phone_identifying(bool value) {
  set_has_is_phone_identifying();
  is_phone_identifying_ = value;
}

// optional bool is_phone_needing_reverify = 19;
inline bool CMsgClientAccountInfo::has_is_phone_needing_reverify() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMsgClientAccountInfo::set_has_is_phone_needing_reverify() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMsgClientAccountInfo::clear_has_is_phone_needing_reverify() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMsgClientAccountInfo::clear_is_phone_needing_reverify() {
  is_phone_needing_reverify_ = false;
  clear_has_is_phone_needing_reverify();
}
inline bool CMsgClientAccountInfo::is_phone_needing_reverify() const {
  return is_phone_needing_reverify_;
}
inline void CMsgClientAccountInfo::set_is_phone_needing_reverify(bool value) {
  set_has_is_phone_needing_reverify();
  is_phone_needing_reverify_ = value;
}

// -------------------------------------------------------------------

// CMsgClientChallengeRequest

// optional fixed64 steamid = 1;
inline bool CMsgClientChallengeRequest::has_steamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientChallengeRequest::set_has_steamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientChallengeRequest::clear_has_steamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientChallengeRequest::clear_steamid() {
  steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid();
}
inline ::google::protobuf::uint64 CMsgClientChallengeRequest::steamid() const {
  return steamid_;
}
inline void CMsgClientChallengeRequest::set_steamid(::google::protobuf::uint64 value) {
  set_has_steamid();
  steamid_ = value;
}

// -------------------------------------------------------------------

// CMsgClientChallengeResponse

// optional fixed64 challenge = 1;
inline bool CMsgClientChallengeResponse::has_challenge() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMsgClientChallengeResponse::set_has_challenge() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMsgClientChallengeResponse::clear_has_challenge() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMsgClientChallengeResponse::clear_challenge() {
  challenge_ = GOOGLE_ULONGLONG(0);
  clear_has_challenge();
}
inline ::google::protobuf::uint64 CMsgClientChallengeResponse::challenge() const {
  return challenge_;
}
inline void CMsgClientChallengeResponse::set_challenge(::google::protobuf::uint64 value) {
  set_has_challenge();
  challenge_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_steammessages_5fclientserver_5flogin_2eproto__INCLUDED
